Креирање дрвета израза
----------------------

У наставку ћемо приказати како се технике које смо до сада научили
могу применити да би се направио наизглед прилично напредан програм
који црта график математичке функције једне променљиве коју корисник
уноси у облику ниске карактера. У овом програму ћемо употребити
технике програмирања које се уче у склопу предмета
"Објектно-оријентисано програмирање": дефинисање класа, објеката,
наслеђивање, апстрактне класе, полиморфизам. Стога ти саветујемо да
се, ако је потребно, подсетиш тих техника када год је потребно, док
читаш наредни текст. Ако те технике још ниси научио, одложи читање
остатка овог поглавља за касније.

Основна идеја је да на основу унетог текстуалног описа математичке
функције формирамо у меморији репрезентацију те функције у облику који
омогућава да се веома једноставно израчунава њена вредност за задату
вредност променљиве ``x``. Најзгодније је да то буде нека дрволика
репрезентација, са различитим врстама чворова: чворовима који
представљају контанте, променљиве, бинарне операције (плус, минус,
пута, подељено), позиве функција (корен, синус, логаритам)
итд. Најзгодније је сваку врсту чвора дрвета представити објектом
посебне класе. Све те класе су врсте израза, па ће представљати
наследнице апстрактне класе израз. Дефинисаћемо две методе:

- метода ``Vrednost`` ће враћати вредност чвора (тј. израза
  представљеног поддрветом чији је корен тај чвор) за дату вредност
  променњиве ``x``.

- метода ``Stampaj`` ће нам служити само за дебаговање и штампаће у
  конзолу текстуалну репрезентацију формираног израза, у потпуно
  заграђеном облику.

Погледајмо како би та хијерархија класа могла бити дефинисана. У класи
``Izraz`` постоји и статичка метода ``Parsiraj`` која гради дрво
израза на основу дате ниске карактера, међутим, цела њена
функционалност је реализована у засебној класи коју ћемо звати
``IzrazParser``.
  
.. activecode:: grafik_funkcije_izraz
    :passivecode: true
    :coach:
    :includesrc: _src/3_tekstualni/grafik_funkcije_izraz.cs

Видиш да је у коду за сада подржана само функција кореновања. Прошири
програм тако да подржиш још неке функције (на пример, тригонометријске
и инверзне тригонометријске функције, логаритамску и експонецијалну
функцију и слично).

Пређимо сада на парсирање. Као што то добра пракса обично налаже,
приликом имплементације парсера, згодно је издвојити лексички
анализатор у засебан модул. Задатак лексичког анализатора је да из
унете ниске врати наредни токен. На пример, ако је унети текст
``x + sqrt(2.1 * x)``, лексички анализатор редом треба да враћа наредне
токене:

::

   x      PROMENLJIVA
   +      PLUS
   sqrt   ID
   (      OTVORENA_ZAGRADA
   2.1    KONSTANTA
   *      PUTA
   x      PROMENLJIVA
   )      ZATVORENA_ZAGRADA
          KRAJ

При том се све белине прескачу.          
          
Имплементација лексичког анализатора је реализована у засебној класи
``IzrazLekser``. Најкомпликованија је метода ``SledeciToken`` чији је
задатак да препозна следећи токен на улазу. Улаз се чува у променљивој
чланици ``_s`` типа ``string``, а променљива чланица ``_i`` означава
позицију наредног необрађеног карактера те ниске. Када се препозна
токен ``KONSTANTA`` важно је знати и која је вредност константе која
је пронађена. Стога се та вредност чува у променљивој чланици
``_vrednost``, слично, за идентификаторе нам је битно да знамо који је
идентификатор препознат, па његове карактере чувамо у оквиру
променљиве чланице ``_naziv``. Делови улаза који одговарају
препознатим токенима се у теорији називају **лексеме**. Када се не
препозна ни један од обичних токена, враћа се специјални токен
``KRAJ`` којим се сигнализира да се дошло до краја исправног дела
улаза.
   
.. activecode:: grafik_funkcije_lekser
    :passivecode: true
    :coach:
    :includesrc: _src/3_tekstualni/grafik_funkcije_lekser.cs

Пре имплементације парсирања, није лоше истестирати лексички
анализатор. На пример,

.. activecode:: grafik_funkcije_lekser_test
    :passivecode: true
    :coach:

    static void Main()
    {
        IzrazLekser lekser = new IzrazLekser("x +sqrt(2.1 * x)");
        Token token;
        while ((token = lekser.SledeciToken()) != Token.KRAJ)
        {
             Console.Write(token);
             if (token == Token.KONSTANTA)
                Console.Write(" " + lekser.Vrednost());
             if (token == Token.ID)
                Console.Write(" " + lekser.Tekst());
             Console.WriteLine();
        }
    }

Када имамо овакав лексички анализатор на располагању, можемо прећи на
имплементацију парсера. Користимо технику рекурзивног спуста, по узору
на програме које смо раније видели. Променљива чланица ``_token`` чува
следећи токен који је на улазу. Наредна једноставна имплементација
подразумева да је израз увек коректно задат. Покушај да је допуниш
проверама које осигуравају да ће грешка увек исправно бити пријављена
у случају да

.. activecode:: grafik_funkcije_parser
    :passivecode: true
    :coach:
    :includesrc: _src/3_tekstualni/grafik_funkcije_parser.cs

Досадашња инфраструктура нам омогућава да израчунамо вредност функције
коју корисник уноси.

.. activecode:: grafik_funkcije_primer
    :passivecode: true
    :coach:

    static void Main()
    {
        Console.Write("Unesi matematicku funkciju:");
        string s = Console.ReadLine();
        Izraz izraz = Izraz.Parsiraj(s);
        Console.Write("Unesi vrednost promenljive x:");
        double x = double.Parse(Console.ReadLine());
        Console.WriteLine(izraz.Vrednost(x));
    }


Сада имамо све потребне елементе за тражену графичку апликацију и
препуштамо вам да је до краја реализујете. Направите поље за унос
текста (``TextBox``) у које корисник уноси функцију, платно за цртање
(``PictureBox``) и дугме за цртање (``Button``). Након клика на дугме,
чита се садржај унет у поље за унос текста, парсира се и гради се
``Izraz``. Претпоставите за почетак да су координате света фиксиране
на неке вредности (на пример, обе координате могу бити у интервалу
од -1 до 1) и дефинишите функције за прерачунавања из координата света
у координате екрана и обратно, из координата екрана у координате
света. Направите затим петљу која пролази кроз пикселе платна за
цртање његовом ширином (нпр. гледа сваки пиксел), затим екранску x
координату тог пиксела преводи у координату света, израчунава вредност
израза за тако добијену координату и на крају такво y добијено у
координатном систему света преводи назад у екрански координати систем
да би нацртала одговарајући пиксел. Уместо цртања појединачних
пиксела, могуће је цртати и изломљену линију тако што се спајају
суседни пиксели графика.
