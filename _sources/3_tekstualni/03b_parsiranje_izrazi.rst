Израчунавање вредности аритметичких израза
------------------------------------------

Пређимо сада на израчунавање вредности произвољних, а не само потпуно
заграђених израза. Постоји неколико начина да се то уради.

Рекурзивни спуст
................

Кренимо од рекурзивног спуста. Проблем са граматиком

::

   <izraz> ::= <konstanta> 
   <izraz> ::= <promenjiva> 
   <izraz> ::= "(" <izraz> ")"
   <izraz> ::= <izraz> "+" <izraz>
   <izraz> ::= <izraz> "*" <izraz>

је то што се у њој дефинисани оператори ``+`` и ``*`` никако не разликују 
по свом приоритету. Размотримо зато шта треба да се промени у дефиницији 
граматике, да бисмо узели у обзир и приоритет оператора. Пошто је сабирање 
операција нижег приоритета, на највишем нивоу сваки израз се састоји од 
једног или више сабирака. На пример:

- ``2+3*4`` има два сабирка, ``2`` и ``3*4``
- ``(3+4)*2+(5+2)*3+1`` има три сабирка, ``(3+4)*2``, ``(5+2)*3`` и ``1``
- ``(1+2)*(3+4)`` има само један сабирак (без обзира што његови подизрази 
  имају више сабирака). 
  
Сваки сабирак се састоји од једног или више чинилаца. Сваки чинилац је
или број или израз у заградама. На пример, израз ``(3+4)*2`` има два
чиниоца, док ``1`` и ``(4*2+5)`` имају само један чинилац.  Тиме се
долази до следеће граматике у EBNF (сабирци су именовани називом терм,
а чиниоци називом фактор).

::

    <izraz>  ::= <term> {"+" <term>}
    <term>   ::= <faktor> {"*" <faktor>}
    <faktor> ::= <broj> | "(" <izraz> ")"

Подсетимо се, витичасте заграде у EBNF означавају да се оно у њима
јавља нула или више пута (на пример, израз је један сабирак иза којег
могу да се нула или више пута јаве плус и неки нови сабирак.

Граматику можемо врло једноставно да проширимо операторима одузимања и 
дељења, поштујући при томе приоритет свих оператора. 

::

    <izraz>  ::= <term> {("+"|"-") <term>}
    <term>   ::= <faktor> {("*"|"/") <faktor>}
    <faktor> ::= <broj> | "(" <izraz> ")"

Надаље, под појмом терм поред сабирака подразумевамо и умањеник и умањилац, 
а под појмом фактор поред чинилаца подразумевамо и дељеник и делилац.

Вредност израза рачунамо техником рекурзивног спуста. Сваки нетерминал
граматике ћемо представити посебном функцијом, која чита део израза
који настаје из тог нетерминала и враћа вредност тог дела
израза. Функцији се по референци преноси индекс `i` који означава
почетак дела ниске `s` који се анализира. На крају рада функције овај
индекс се премешта иза прочитаног дела ниске. Променљива `ok` која се
такође преноси по референци је индикатор да ли је дошло до грешке
дељења нулом током израчунавања вредности израза. Још једно проширење
у односу на претходни, упрошћени програм је то што допуштамо да у
изразима учествују и вишецифрени бројеви (а не само
једноцифрени). Читање и одређивање вредности бројева је ручно
имплементирано, а за вежбу вам остављамо да покушате да за ово
употребите регуларне изразе.

.. activecode:: rekspust2
    :passivecode: true
    :coach:
    :includesrc: _src/3_tekstualni/rekspust2.cs

Приметимо да се у претходном програму користи узајамна рекурзија
(функција ``izraz`` позива функцију ``term`` која позива функцију
``faktor``, а која позива функцију ``izraz``).

Коришћење стека
...............

Проблем се решава слично као код потпуно заграђених израза, али овај
пут се мора обраћати пажња на приоритет и асоцијативност оператора.

Једноставности ради претпоставимо прво да не израчунавамо вредност
израза, већ само израз пребацујемо у тзв. постфиксни облик који нам
даје веома једноставно упутство како би се вредност израза могла
израчунати (уз коришћење помоћног стека). У постфиксном облику, 
оператор се не пише између, него након операнада. На пример, постфиксни 
облик израза ``(3+4)*5`` је ``34+5*``. Захваљујући оваквом редоследу 
писања, у постфиксном облику израза заграде нису потребне. Погледајмо 
на примеру истог израза како тече израчунавање вредности на основу 
постфиксног записа: прво на стек вредности (овде је то једини стек) 
треба ставити бројеве 3 и 4; затим, наиласком на знак ``+`` те две 
вредности треба скинути са стека и заменити њиховим збиром (бројем 
7); затим се на стек ставља и број 5, а наиласком на знак ``*`` са стека 
се скидају вредности 7 и 5 и замењују њиховим производом (бројем 35).

Изрази се обично записују у једном од три наредна облика:

- постфиксни облик (на пример, ``34+5*``) је, видели смо, облик у ком
  се оператор исписује након својих операнада

- инфиксни облик (на пример, ``(3+4)*5``) је класичан облик записа
  израза и у њему се оператор записује између својих операнада

- префиксни облик (на пример, ``*+345``) је облик у коме се оператор
  записује испред својих операнада. Овај облик је веома погодан за парсирање,
  јер се структура израза (водећи оператор) може открити већ на самом
  почетку (у примеру се види да је у питању "производ збира бројева 3
  и 4 и броја 5").

Превођење потпуно заграђених израза у постфиксни облик би било јако
једноставно:

- када наиђемо на број преписујемо га на излаз;
- када наиђемо на оператор стављамо га на стек;
- када наиђемо на затворену заграду скидамо оператор са стека и
  преписујемо га на излаз.

Заиста, потпуно заграђена форма претходног израза је
``((3+4)*5)``. Отворене заграде прескачемо, преписујемо ``3`` на
излаз, стављамо ``+`` на стек, преписујемо ``4`` на излаз и онда,
пошто смо наишли на затворену заграду пребацујемо ``+`` са стека на
излаз. Након тога на стек стављамо ``*``, преписујемо ``5`` на излаз и
при наиласку на другу затворену заграду пребацујемо ``*`` са стека на
излаз, чиме добијамо постфиксни облик ``34+5*``. Ако излаз заменимо
стеком вредности и пребацивање оператора на излаз заменимо њиховом
применом на стеку вредности, добићемо алгоритам који израчунава
вредност израза.

Пређимо сада на случај израза који не мора бити потпуно
заграђен. Кључна дилема је шта радити у ситуацији када се прочита
`op2` у изразу облика ``i1 op1 i2 op2 i3`` где су ``i1``, ``i2`` и
``i3`` три израза (било броја било израза у заградама), а ``op1`` и
``op2`` два оператора. У том тренутку на излазу ће се налазити израз
``i1`` преведен у постфиксни облик и иза њега израз ``i2`` преведен у
постфиксни облик, док ће се оператор ``op1`` налазити на врху стека
оператора. Уколико ``op1`` има виши приоритет од оператора ``op2`` или
уколико им је приоритет исти, али је асоцијативност лева (врши се
израчунавање слева надесно, што је прилично уобичајено), тада је
потребно прво израчунавати израз ``i1 op1 i2`` тиме што се оператор
``op1`` са врха стека пребаци на излаз. У супротном (ако ``op2`` има
виши приоритет или ако је приоритет исти, а асоцијативност десна)
оператор ``op1`` остаје на стеку и изнад њега се поставља оператор
``op2``.


Наредна анимација приказује примену овог алгоритма на једном примеру.

.. gallery:: shunting_algoritam
    :width: 600px
    :height: 100%
    :folder: ../../_images/3_tekstualni/shunting
    :images: shunting0.png, shunting1.png, shunting2.png, shunting3.png, shunting4.png, shunting5.png, shunting6.png, shunting7.png, shunting8.png, shunting9.png, shunting10.png, shunting11.png, shunting12.png, shunting13.png, shunting14.png, shunting15.png, shunting16.png, shunting17.png


Уместо превођења у постфиксни облик, можемо одмах израчунавати
вредност израза (тако што се уместо текстуалног излаза користи стек
вредности).

.. gallery:: shunting_algoritam_val
    :width: 600px
    :height: 100%
    :folder: ../../_images/3_tekstualni/shunting
    :images: shunting_val0.png, shunting_val1.png, shunting_val2.png, shunting_val3.png, shunting_val4.png, shunting_val5.png, shunting_val6.png, shunting_val7.png, shunting_val8.png, shunting_val9.png, shunting_val10.png, shunting_val11.png, shunting_val12.png, shunting_val13.png, shunting_val14.png, shunting_val15.png, shunting_val16.png, shunting_val17.png, shunting_val18.png

У наставку је приказана имплементација овог алгоритма у језику C#. И
стек вредности и стек оператора су представљени библиотечком
колекцијом ``Stack`` (метода ``Push`` ставља елемент на врх стека,
``Pop`` скида елемент са врха стека, ``Peek`` очитава елемент са врха
непразног стека, али га не скида са стека, док својство ``Count``
означава тренутни број елемената на стеку и користи се да би се
проверило да ли је стек празан).


.. activecode:: stek2
    :passivecode: true
    :coach:
    :includesrc: _src/3_tekstualni/stek2.cs

Ово је један од многих алгоритама које је извео Едсгер Дајкстра и
назива се на енглеском језику **Shunting yard algortihm**, што би се
могло слободно превести као алгоритам сортирања железничких
вагона. Замислимо да израз треба да пређе са једног на други крај
пруге. На прузи се налази споредни колосек (пруга је у облику слова Т
и споредни колосек је усправна црта). Делови израза прелазе са десног
на леви крај (замислимо да иду по горњој ивици слова Т). Бројеви увек
прелазе директно. Оператори се увек задржавају на споредном колосеку,
али тако да се пре него што оператор уђе на споредни колосек са њега
на излаз пребацују сви оператори који су вишег приоритета у односу на
текући или имају исти приоритет као текући а лево су асоцијативни. И
отворене заграде се постављају на споредни колосек, а када наиђе
затворена заграда, са споредног колосека се уклањају сви оператори до
отворене заграде. Када се исцрпи цео израз на десној страни, сви
оператори са споредног колосека се пребацују на леву страну. Јасно је
да споредни колосек има понашање стека, тако да се у имплементацији
користи стек (на њега се стављају оператори).
