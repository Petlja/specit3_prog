Поређење стрингова
==================

У групу метода који се користе за поређење стрингова могу да се уброје ови методи:

- ``String.Equals``: проверава да ли су два стринга једнака (може да поистовети мала и велика слова)
- ``String.Compare``: проверава који од два стринга претходи другом у сортираном редоследу (могућа су детаљна подешавања поређења)
- ``StartsWith``: проверава да ли текућа инстанца стринга почиње наведеним карактером или стрингом
- ``EndsWith``: проверава да ли текућа инстанца стринга завршава наведеним карактером или другим стрингом

Поред употребе метода ``Equals``, једнакост и неједнакост стрингова можемо једноставно да проверавамо 
помоћу релацијских оператора ``==`` и ``!=``, на пример:

.. code::

    if (s1 == s2) 
        Console.WriteLine(s1 + "==" + s2);
    if (s1 != s2) 
        Console.WriteLine(s1 + "!=" + s2);

Приметимо да у језику `C#` за стрингове нису дефинисани релацијски оператори ``<``, ``>``, ``<=`` 
и ``>=``, већ се за то користе методи ``Compare`` и ``CompareTo``. Вероватно је процењено да би 
постојање релацијских оператора за стрингове донело више штете него користи, јер није јасно какво 
понашање би од ових оператора очекивао неко ко жели да упоређује стрингове помоћу њих. Наиме, 
стрингове је могуће поредити на више начина, који могу да се поделе на две групе:

- **нелингвистичка поређења**, којима се упоређују кодови карактера до наиласка на прву разлику. 
  Подразумева се да стринг који на позицији са првом разликом садржи карактер са мањим кодом, у 
  сортираном редоследу претходи другом стрингу.
- **лингвистичка (језичка) поређења**, којима се упоређују стрингови узимајући у обзир специфичности 
  одређене културе, тј. правописа одређеног језика, као што је азбучни (абецедни) редослед, 
  поистовећивање одређених слова или група слова (нпр. `ß <https://sr.wikipedia.org/wiki/%C3%9F>`_ 
  и `ss` у немачком правопису) и слично. 

Примери
-------

Лингвистичко и нелингвистичко поређење
''''''''''''''''''''''''''''''''''''''

Следећи програм илуструје употребу нелингвистичког и лингвистичког поређења.

.. activecode:: uvod_poredjenje_stringova
    :passivecode: true
    :coach:
    :includesrc: _src/3_tekstualni/uvod_poredjenje_stringova.cs

Резултат извршавања је

.. code::

    А je posle Ј
    А je pre Ј

Видимо да ова поређења дају различите резултате. То је зато што азбучни редослед слова и редослед 
кодова (јуникод кодних тачака) ћириличних слова нису исти. Конкретно, кôд слова ``Ј`` је мањи 
од кода слова ``А``, па по редоследу кодова слово ``Ј`` претходи слову ``А`` (у нашој азбуци је 
редослед, наравно, обрнут). Ако нас занима редослед кодова свих малих и великих ћириличних слова 
српског језика, можемо да искористимо слично подешавање начина поређења стрингова и приликом 
сортирања. То је илустровано у следећем примеру. 


Лингвистичко и нелингвистичко сортирање
'''''''''''''''''''''''''''''''''''''''

.. activecode:: uvod_sortiranje_stringova
    :passivecode: true
    :coach:
    :includesrc: _src/3_tekstualni/uvod_sortiranje_stringova.cs

Програм исписује

.. code::

    Nesortirano:
    шџчцхфућтсрпоњнмљлкјизжеђдгвбаШЏЧЦХФУЋТСРПОЊНМЉЛКЈИЗЖЕЂДГВБА
    Sortirano koristeci tekucu kulturu:
    аАбБвВгГдДђЂеЕжЖзЗиИјЈкКлЛљЉмМнНњЊоОпПрРсСтТћЋуУфФхХцЦчЧџЏшШ
    Sortirano po kodovima karaktera:
    ЂЈЉЊЋЏАБВГДЕЖЗИКЛМНОПРСТУФХЦЧШабвгдежзиклмнопрстуфхцчшђјљњћџ

Ову разлику у редоследу слова треба имати на уму и у програмима бирати ону врсту поређења која 
одговара потребама. На пример, нелингвистичко поређење можемо да користимо када сортирамо велике 
количине текстуалних података који немају (тј. не очекује се да имају) језички смисао. Такви су, 
рецимо, разни симболички подаци, ознаке (лабеле), јединствени идентификатори (`ID`), лозинке и 
слично. Нелингвистичко поређење је једноставније, па зато и ефикасније (брже) од лингвистичког, 
које укључује сложенија правила. 

У другачијој ситуацији, подаци који имају језички смисао и које приказујемо кориснику програма, 
треба да упоређујемо лингвистички, тј. узимајући у обзир језичка правила. 

Поређење стрингова може да се контролише врло детаљно и овде не можемо да се упуштамо у све постојеће 
могућности. Уместо тога, дајемо само још један пример да бисмо наговестили каква су све поређења могућа.

Подешавање поређења
'''''''''''''''''''

.. activecode:: uvod_poredjenje_cekic
    :passivecode: true
    :coach:
    :includesrc: _src/3_tekstualni/uvod_poredjenje_cekic.cs

Програм исписује:

.. code::

    None: čekić je posle Cekic
    IgnoreNonSpace: čekić je pre Cekic
    IgnoreCase: čekić je posle Cekic
    IgnoreCase, IgnoreNonSpace: čekić i Cekic su ekvivalentni

Дати пример показује да приликом поређења 

- мала и велика слова могу, а не морају да се третирају као једнака.
- слова са дијакритицима (нпр. `Č`, `Ć`, `Ž` и друга) могу, а не морају да се третирају као једнака 
  одговарајућем слову без дијакритика (`C`, `Z`).
- овакве могућности могу да се подесе независно једна од друге и користе упоредо.

Испратите детаљно програм и добијени резултат, а затим објасните зашто се добија баш такав резултат, 
знајући да параметар ``IgnoreNonSpace`` изједначава слово са дијакритиком и слово без дијакритика, а 
параметар ``IgnoreCase`` изједначава мало и велико слово. 

Подсећамо да више детаља о различитим варијантама метода ``Compare``, којих у актуелној верзији 
библиотеке има чак 10, може да се пронађе у званичној онлајн документацији.

Други корисни методи за поређење стрингова су ``Equals``, ``StartsWith`` и ``EndsWith``. Основна 
употреба ових метода би требало да је јасна, па се на њима нећемо задржавати. Поменимо само да ови 
методи такође имају извесне могућности подешавања начина поређења, тако да могу да се прилагоде 
потребама, слично као метод ``Compare``.                                               

.. infonote::

    Задатке за вежбу можете да нађете на страници `Стрингови и регуларни изрази - задаци
    <02e_regexi_zadaci.html>`_, после лекција о регуларним изразима.
