Потпуно заграђени изрази
------------------------

Циљ нам је да прикажемо како написати програм који анализира
исправност и израчунава вредности аритметичких израза. То ћемо урадити
поступно, тако што ћемо прво решити упрошћен случај **потпуно
заграђених израза**. То су изрази који имају заграде око сваке примене
аритметичког оператора. На пример,

::

   (((3*5)+(7+(2*1)))*4)

Чињеница да је израз потпуно заграђен олакшава израчунавање, јер нема
потребе да водимо рачуна о приоритету и асоцијативности оператора.
Такви изрази се описују наредном, веома једноставном граматиком.

::
   
   <izraz> :: <cifra>
   <izraz> :: '(' <izraz> '+' <izraz> ')'
   <izraz> :: '(' <izraz> '*' <izraz> ')'


Приметимо још једно значајно упрошћење - изрази су формирани само од
цифара и вишецифрени бројеви нису допуштени.

Када на овом, упрошћеном случају упознамо основне технике, применићемо их
и у општем случају.

Рекурзивни спуст
................

Пошто је граматички опис суштински рекурзиван, један природан начин да
се приступи решавању проблема је да и програм користи
рекурзију. Обрада структурираног текстуалног улаза рекурзивним
функцијама се назива **рекурзивни спуст** (енгл. recursive
descent). Дефинишемо рекурзивну функцију чији је задатак да израчуна
вредност дела ниске који представља исправан аритметички израз. Он
може бити или број или израз у заградама.

- Случај када је израз број је излаз из рекурзије и израчунавање
  вредности таквог израза је тривијално, јер је вредност израза
  једнака вредности тог броја тј. цифре.

- У случају израза у заградама читамо прво отворену заграду, затим
  рекурзивним позивом израчунавамо вредност првог операнда, након тога
  читамо оператор, затим рекурзивним позивом израчунавамо вредност
  другог операнда, након тога читамо затворену заграду и израчунавамо
  вредност познајући оператор и вредност оба операнда.

Ниска која се обрађује не мора да се мења током рекурзивних позива,
међутим, рекурзивна функција у сваком рекурзивном позиву обрађује део
ниске, који креће од неке позиције. Нека се та позиција чува у
променљивој ``i``. Ако, на пример, израз облика ``(izraz+izraz)``
почиње на некој позицији ``i``, тада први рекурзивни позив треба да
анализира ниску од позиције ``i+1`` (јер се отворена заграда
прескаче). Након завршетка првог рекурзивног треба очитати оператор,
међутим не знамо на којој се позицији он налази. Кључна идеја је да
наша рекурзивна функција добије додатни задатак: задатак рекурзивне
функције је да прочита израз који почиње на позицији ``i``, да
израчуна његову вредност и да променљиву ``i`` промени тако да њена
нова вредност указује на позицију ниске непосредно након израза који
је прочитан. Променљива ``i`` мења своју вредност кроз рекурзивне
позиве. Стога ћемо је преносити по референци, тако да представља и
улазну и излазну величину функције.

Имајући све ово у виду, једноставно можемо направити имплементацију у језику C#.

.. activecode:: rekspust1
    :passivecode: true
    :coach:
    :includesrc: _src/3_tekstualni/rekspust1.cs

Коришћење стека
...............

Као што је већ познато, рекурзија се може елиминисати коришћењем
стека. На стек можемо стављати све симболе док не наиђемо на затворену
заграду. У том тренутку:

- са стека скидамо два операнда, оператор и отворену заграду;
- израчунавамо вредност израза добијеног применом оператора на операнде;
- на стек стављамо резултат. 

Размотримо пример израза ``((3+4)*(5+6))``. Обрађујемо редом један по
један карактер. До прве затворене заграде, на стек стављамо један по
један симбол и стек тада изгледа овако.


::

        4     <-  vrh
        +
        3
        (
        (
       ----
       stek

Пошто смо наишли на затворену заграду покрећемо израчунавање и
долазимо до следећег стања:

::

        7     <-  vrh
        (
       ----
       stek

Након тога настављамо читање до наредне затворене заграде. Пре њеног
читања, стек овако изгледа:


::

       6      <-  vrh
       +
       5
       (
       *
       7
       (
      ----
      stek


Наилазимо на прву од две затворене заграде, покрећемо израчунавање и
долазимо до следећег стања.

::

      11     <-  vrh
       *
       7
       (
      ----
      stek
      
На крају долазимо до друге затворене заграде, покрећемо израчунавање и
долазимо до стања:

::

      77     <-  vrh
      ----
      stek

Примећујемо да се тражена вредност израза налази на стеку вредности.

Постављање отворених заграда на стек у овом алгоритму не доприноси
ничему корисном, па се може прескочити (на стек можемо стављати само
бројеве и операторе).

Имплементацију овог алгоритма у језику C# отежава то што није јасно
који тип података се поставља на стек (за разлику од, на пример,
језика Python у коме листе могу садржати истовремено податке
различитог типа, у језику C# сви елементи колекције морају имати
јединствен тип). Зато ћемо уместо једног у програму одржавати два
стека: један на који ћемо постављати бројеве (вредности операнада), а
на други карактере (ознаке оператора).

- Када наиђемо на цифру постављаћемо је на стек вредности операнада.
- Када наиђемо на оператор, постављаћемо га на стек оператора.
- Када наиђемо на затворену заграду, тада ћемо скидати два операнда са
  стека вредности операнада, оператор са стека оператора, применићемо
  оператор на операнде и резултат стављати на стек вредности
  операнада.

Размотримо пример израза ``((3+4)*(5+6))``. Обрађујемо редом један по
један карактер. Отворене заграде можемо да прескочимо, а када наиђемо
на карактер ``3``, стављамо га на стек вредности. Након тога ``+``
стек оператора, а затим ``4`` на стек вредности. У том тренутку
стекови изгледају овако:

::

       4
       3             +
   ---------     ---------
   vrednosti     operatori

Пошто смо наишли на затворену заграду покрећемо израчунавање и
долазимо до следећег стања:

::

       7             
   ---------     ---------
   vrednosti     operatori

Након тога на стек оператора постављамо оператор множења ``*``.

::

       7             *
   ---------     ---------
   vrednosti     operatori


Отворену заграду прескачемо, а затим на стек вредности стављамо ``5``,
на стек оператора ``+``, па на стек вредности ``6``. У том тренутку
стекови изгледају овако.

::

       6
       5             +
       7             *
   ---------     ---------
   vrednosti     operatori

Наилазимо на прву од две затворене заграде, покрећемо израчунавање и
долазимо до следећег стања.

::

      11           
       7             *
   ---------     ---------
   vrednosti     operatori

На крају долазимо до друге затворене заграде, покрећемо израчунавање и
долазимо до стања:

::

      77             
   ---------     ---------
   vrednosti     operatori

Примећујемо да се тражена вредност израза налази на стеку вредности.   

Имплементација ове технике је дата у следећем C# коду. Користимо
библиотечку имплементацију стека (класа ``Stack`` са методима ``Push``
за постављање елемената на стек и ``Pop`` за скидање елемента са стека).

.. activecode:: stek1
    :passivecode: true
    :coach:
    :includesrc: _src/3_tekstualni/stek1.cs
