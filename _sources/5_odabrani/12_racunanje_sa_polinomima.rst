Рачунање са полиномима
======================

Када се операције сабирања, одузимања, множења и дељења полинома имплементирају онако како их и ми 
сами рачунамо, задатак није алгоритамски нарочито интересантан, али може да буде поучан у контексту 
дизајна софтвера.

Алгоритамски интересантан део ове лекције је ефикасан рекурзиван алгоритам за множење полинома, који 
омогућава да за велике степене полинома до резултата дођемо уз мање операција над бројевима, него 
уобичајеним приступом. Тај алгоритам је познат као Карацубин алгоритам, по математичару Анатолију 
Карацуби који га је смислио 1960. године.

Карацубин алгоритам  је један од првих из групе алгоритама, који су касније постали познати као 
алгоритми типа **подели и савладај** (енгл. *divide and conquer*). Вероватно су вам од раније познати 
неки алгоритми овог типа, нпр. *Quick Sort* или *Merge Sort*. Алгоритам брзе Фуријеове трансформације 
(енгл. Fast Fourier Transform, скр. FFT), који је изузетно значајан у решавању разних инжењерских 
проблема, сродан је Карацубином и такође спада у алгоритме типа подели и савладај. Имајући ово на уму, 
идеја Карацубиног алгоритма је свакако вредна упознавања, јер су сличне идеје примењене у решавању 
многих других проблема. 

У овој лекцији ћемо се прво задржати на уредној имплементацији метода потребних за рад са полиномима, 
водећи рачуна о детаљима. На крају ћемо објаснити идеју Карацубиног алгоритма и проанализирати број 
операција.

Полоними и рачунске операције над њима
--------------------------------------

Као што знамо, полином је задат својим степеном и низом коефицијената. Овде ћемо подразумевати да 
је једина променљива у свим полиномима :math:`x`, да су коефицијенти реални бројеви и да се задају 
редом, почевши од најстаријег, тј. оног уз највиши степен променљиве. На пример, полином 
:math:`P(x) = 2x^3 - 5x^2 + 7`  задат је степеном 3 и коефицијентима 2, -5, 0, 7. За степен полинома 
ћемо користити ознаку :math:`deg`, тако да за овај полином можемо да пишемо :math:`deg(P) = 3`. Када 
кажемо да је степен неког полинома :math:`n`, подразумевамо да је коефицијент 
уз степен :math:`n` различит од нуле, а да су сви остали чланови полинома нижег степена од :math:`n`. 
Специјално, за **нула-полином** код кога су сви коефицијенти нуле, кажемо да је степена -1.
Коефицијент уз највиши степен полинома називамо **водећи коефицијент**, а коефицијент уз :math:`x^0` 
зовемо **слободан коефицијент**. 

Од операција над полиномима, разматраћемо сабирање, одузимање, множење, дељење без остатка и рачунање 
остатка при дељењу. При извођењу ових операција користе се следећа правила рачунања са полиномима:

- :math:`a \cdot x^k + b \cdot x^k = (a+b) \cdot x^k`. На пример, :math:`14 x^3 + 4 x^3 = 18 x^3`
- :math:`a \cdot x^k - b \cdot x^k = (a-b) \cdot x^k`. На пример, :math:`14 x^5 - 4 x^5 = 10 x^5`
- :math:`(a \cdot x^k) \cdot (b \cdot x^j) = (a \cdot b) \cdot x^{k+j}`. На пример, :math:`2 x^3 \cdot 3 x^5 = 6 x^8`
- :math:`\frac{a \cdot x^k}{b \cdot x^j} = \frac{a}{b} \cdot x^{k-j}`. На пример, :math:`\frac{6 x^7}{2 x^5} = 3 x^2`

**Операције сабирања и одузимања полинома**

Приликом сабирања и одузимања полинома, међусобно се сабирају и одузимају чланови са једнаким експонентима 

- пример сабирања полинома: :math:`(2x^3-x^2+5x-3) + (7x^2 + 4) = 2x^3 + 6x^2 +5x + 1`
- пример одузимања полинома: :math:`(2x^3-x^2+5x-3) - (7x^2 + 4) = 2x^3 - 8x^2 +5x - 7`

**Множење полинома**

Приликом множења полинома користи се дистрибутивни закон, тј. сваки члан једног полинома се множи 
сваким чланом другог. На пример:

.. math::

    \begin{aligned}
    (3x^2 - 2x + 5) \cdot (4x^3 + 3x + 2) &= (3x^2 - 2x + 5) \cdot 4x^3 + (3x^2 - 2x + 5) \cdot 3x + (3x^2 - 2x + 5) \cdot 2 \\
    &= (12x^5 - 8x^4 + 20x^3) + (9x^3 - 6x^2 + 15x) + (6x^2 - 4x + 10)\\
    &= 12x^5 - 8x^4 + (20+9)x^3 + (6-6)x^2 + (15-4)x + 10\\
    &= 12x^5 - 8x^4 + 29x^3 + 11x + 10\\
    \end{aligned}

**Дељење полинома**

Поступак дељења полинома је сличан поступку целобројног дељења вишецифрених бројева, при коме се 
поред количника добија и остатак. Нека су 

.. math::

    P_n = a_n x^n + a_{n-1}x^{n-1} + \cdots + a_1x^1 + a_0\\
    Q_m = b_m x^m + b_{m-1}x^{m-1} + \cdots + b_1x^1 + b_0\\
    
два дата полинома. Желимо да израчунамо полиноме 

.. math::

    R_r = c_r x^r + c_{r-1}x^{r-1} + \cdots + c_1x^1 + c_0\\
    U_u = d_u x^u + d_{u-1}x^{u-1} + \cdots + d_1x^1 + d_0\\
    
такве да је :math:`P = Q \cdot R + U` и при томе :math:`deg(U) < deg(Q)`. 

Као прво, можемо да уочимо да у случају када је степен полинома :math:`P_n` мањи од степена полинома 
:math:`Q_m`, тада је количник нула-полином, тј. :math:`R(x) = 0`, а остатак је читав полином 
:math:`P_n`. У противном, на основу особина производа полинома и уведеног ограничења :math:`deg(U) < deg(Q)`
закључујемо да је водећи члан количника :math:`c_r x^r = \frac{a_n}{b_m}x^{n-m}`. Када ово уврстимо у 
једнакост :math:`P = Q \cdot R + U` добијамо 

.. math::

    \begin{aligned}
    P &= Q \cdot R + U\\
    P &= Q \cdot (c_r x^r + R') + U\\
    P &= Q \cdot c_r x^r + Q \cdot R' + U\\
    P - Q \cdot c_r x^r &= Q \cdot R' + U\\
    P' &= Q \cdot R' + U\\
    \end{aligned}

где смо са :math:`P'` означили полином :math:`P - Q \cdot c_r x^r`, а са  :math:`R'` полином 
:math:`R - c_r x^r`. Да бисмо довршили поступак дељења, сада је потребно да поделимо полином 
:math:`P'` полиномом :math:`Q`, добијемо количник :math:`R'` и израчунамо :math:`R` као 
:math:`R' +  c_r x^r`. Ово је једноставнији задатак од полазног јер је степен полинома :math:`P'` 
мањи од степена полинома :math:`P`, тако да овим поступком можемо да довршимо рачунање количника.

Погледајмо описани поступак на примеру. Поделићемо полиноме :math:`x^5+2x^4-2x^3+9x^2−4x+3` и 
:math:`x^2−3x+4`

- први члан количника је :math:`x^5 / x^2 = x^3`, даље треба делити полином 
  :math:`P' = P - Q x^3 = x^5+2x^4-2x^3+9x^2−4x+3 - (x^2−3x+4) \cdot x^3 = 5x^4-6x^3+9x^2-4x+3`
- други члан количника је :math:`5x^4 / x^2 = 5x^2`, даље треба делити полином 
  :math:`P'' = P' - Q \cdot 5x^2 = 5x^4-6x^3+9x^2-4x+3 - (x^2−3x+4) \cdot 5x^2 = 9x^3-11x^2-4x+3`
- трећи члан количника је :math:`9x^3 / x^2 = 9x`, даље треба делити полином 
  :math:`P''' = P'' - Q \cdot 9x = 9x^3-11x^2-4x+3 - (x^2−3x+4) \cdot 9x = 16x^2 - 40x + 3`
- четврти члан количника је :math:` 16x^2 / x^2 = 16`, преостали полином је
  :math:`P'''' = P''' - Q \cdot 16 = 16x^2 - 40x + 3 - (x^2−3x+4) \cdot 16 = 8 x - 61`. Пошто је овај 
  полином степена мањег од степена полинома :math:`Q`, он представља остатак.

Закључујемо да је количник :math:`R = x^3 + 5 x^2 + 9 x + 16` и остатак :math:`U = 8 x - 61`.
Исправност рачунања можемо да потврдимо провером да важи :math:`P = Q \cdot R + U`.

Имплементација полонима и операција над њима
--------------------------------------------

Природно је да полиноме у програму представимо објектима класе ``Polynomial`` (полином). Према ономе 
што је речено на почетку, класа треба да садржи низ реалних коефицијената ``a`` и својство ``Deg``:

.. activecode:: poc_definicije_klase_polinom
    :passivecode: true

    public class Polynomial
    {
        private List<double> a;

        public int Deg 
        { 
            get { return a != null ? a.Count - 1 : -1; } 
        }
    
        ...
    }

Мада ћемо у кôду за коефицијенте полинома да користимо листу реалих бројева, у даљој анализи 
користимо реч низ, као и до сада. При томе не мислимо на низ у смислу синтаксе језика, него на низ 
као математички појам. 

Резултат сваке од пет помињаних операција над полиномима (сабирање, одузимање, множење, дељење и 
рачунање остатка) је такође полином, за који треба предвидети довољно дугачке низове за коефицијенте. 
Због тога је потребно да пре израчунавања коефицијената резултата знамо степен резултата, односно горње 
ограничење степена резултата. 

Нека су дата два полинома, :math:`P(x)` степена :math:`n` и :math:`Q(x)` степена :math:`m`, дакле 
:math:`deg(P) = n, deg(Q) = m`. Да бисмо имали на уму степене полинома, уобичајено је да их пишемо 
у индексу уз ознаку полинома, овако: :math:`P_n, Q_m`.

Користећи уведене ознаке, констатујмо да за полиноме :math:`P_n, Q_m` важи:

- :math:`deg(P_n + Q_m) \leq \max(n, m)`
- :math:`deg(P_n - Q_m) \leq \max(n, m)`
- :math:`deg(P_n \cdot Q_m) = n + m`
- :math:`deg(\frac{P_n}{Q_m}) = n - m`.

У случају збира или разлике, степен резултата може да буде мањи од :math:`\max(m, n)` ако су 
полиноми :math:`P_n, Q_m` истог степена и коефицијенти уз највиши степен се поништавају. 

Нормализација записа полинома
'''''''''''''''''''''''''''''

Резултат сабирања и одузимања може да буде и било којег нижег степена, па и нула-полином. У случајевима 
када добијемо да је водећи коефицијент неког полинома нула, пожељно је да извршимо нормализацију 
записа тог полинома. На тај начин поједностављујемо имплементацију операција над полиномима и 
штедимо меморију. Нормализација се врши тако што се (на ефикасан начин) уклоне нуле у низу 
коефицијената, нпр. овако:

.. activecode:: normalizacija_zapisa_polinoma
    :passivecode: true


    private void Normalize()
    {
        int n = Deg, k = 0;
        while (k <= n && a[n - k] == 0)
            k++;

        if (k > 0)
            a.RemoveRange(n - k + 1, k);
    }

Имплементација операција над полиномима
'''''''''''''''''''''''''''''''''''''''

Оператори +, -, *
^^^^^^^^^^^^^^^^^

Операције сабирања, одузимања и множења полинома можемо да имплементирамо као следеће методе: 
 
.. activecode:: sabiranje_oduzimanje_i_mnozenje_polinoma
    :passivecode: true

    public static Polynomial operator +(Polynomial P, Polynomial Q)
    {
        if (P.Deg < Q.Deg)
        {
            Polynomial tmp = P; P = Q; Q = tmp;
        }
        Polynomial R = new Polynomial(P);
        for (int i = 0; i <= Q.Deg; i++)
            R.a[i] += Q.a[i];

        R.Normalize();
        return R;
    }

    public static Polynomial operator -(Polynomial P, Polynomial Q)
    {
        Polynomial R;
        if (P.Deg >= Q.Deg)
        {
            R = new Polynomial(P);
            for (int i = 0; i <= Q.Deg; i++)
                R.a[i] -= Q.a[i];
        }
        else 
        {
            R = new Polynomial(Q.Deg);
            for (int i = 0; i <= P.Deg; i++)
                R.a[i] = P.a[i] - Q.a[i];
            for (int i = P.Deg+1; i <= Q.Deg; i++)
                R.a[i] = -Q.a[i];
        }
        R.Normalize();
        return R;
    }

    public static Polynomial operator *(Polynomial P, Polynomial Q)
    {
        Polynomial R = new Polynomial(P.Deg + Q.Deg);
        for (int i = 0; i <= P.Deg; i++)
            for (int j = 0; j <= Q.Deg; j++)
                R.a[i + j] += P.a[i] * Q.a[j];

        return R;
    }

Захваљујући дефиницијама ових оператора, када будемо комплетирали класу ``Polynomial``, у програмима 
који је користе моћи ћемо да пишемо наредбе попут:

.. activecode:: upotreba_operatora
    :passivecode: true
    
    Polynomial R = P + Q;
    Polynomial T = P * Q;

и сличне, где су ``P``, ``Q`` полиноми раније дефинисани у програму.

Оператори /, % (дељење и остатак)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Када ручно делимо два полинома, ми истовремено израчунавамо количник и остатак. Зато ћемо и у 
програму, да не бисмо понављали кôд, да напишемо метод ``DivMod``, у коме се израчунавају оба 
резултујућа полинома. Метод ``DivMod`` може да буде и јаван, да би корисник коме су потребни 
и количник и остатак при дељењу нека два полинома добио резултате ефикасније. За кориснике 
којима је потребан само један од ова два резултујућа полинома, дефинишемо и операторе ``/`` и 
``%``, који се ослањају на метод ``DivMod``.

.. activecode:: deljenje_polinoma
    :passivecode: true

    public static Tuple<Polynomial, Polynomial> DivMod(Polynomial P, Polynomial Q)
    {
        if (P.Deg < Q.Deg)
            return new Tuple<Polynomial, Polynomial>(Zero(), new Polynomial(Q));

        Polynomial Div = new Polynomial(P.Deg - Q.Deg);
        Polynomial Mod = new Polynomial(P);
        for (int i = Div.Deg; i >= 0; i--)
        {
            Div.a[i] = Mod.a[i + Q.Deg] / Q.a[Q.Deg];
            for (int j = 0; j <= Q.Deg; j++)
                Mod.a[j + i] -= Q.a[j] * Div.a[i];
        }
        Mod.Normalize();
        return new Tuple<Polynomial, Polynomial>(Div, Mod);
    }

    public static Polynomial operator /(Polynomial P, Polynomial Q)
    {
        return DivMod(P, Q).Item1;
    }
    public static Polynomial operator %(Polynomial P, Polynomial Q)
    {
        return DivMod(P, Q).Item2;
    }

Ови методи нам омогућавају да након комплетирања класе ``Polynomial`` пишемо: 

.. activecode:: upotreba_operatora_divmod1
    :passivecode: true
    
    Polynomial R = P / Q;
    Polynomial U = P % Q;

или 

.. activecode:: upotreba_operatora_divmod2
    :passivecode: true
    
    var RU = Polynomial.DivMod(P, Q);
    Polynomial R = RU.Item1;
    Polynomial U = RU.Item2;

и слично.

Операције између бројева и полинома
'''''''''''''''''''''''''''''''''''

У математици је уобичајено да се користе записи :math:`P+c, c \cdot P` и слични, где је :math:`P` 
полином. а :math:`c` реалан број. Да бисмо омогућили исту функционалност у програмима, **не морамо** 
да дефинишемо све могуће операторе као што су 

.. activecode:: operatori
    :passivecode: true

    // nepotrebno
    public static Polynomial operator +(Polynomial P, double c)
    { 
        ... 
    }
    public static Polynomial operator +(double c, Polynomial P)
    { 
        ... 
    }
    public static Polynomial operator -(Polynomial P, double c)
    { 
        ... 
    }
    public static Polynomial operator -(double c, Polynomial P)
    { 
        ... 
    }
    public static Polynomial operator *(Polynomial P, double c)
    { 
        ... 
    }
    public static Polynomial operator *(double c, Polynomial P)
    { 
        ... 
    }
    public static Polynomial operator /(Polynomial P, double c)
    { 
        ... 
    }

и слични. Довољно је да напишемо оператор који омогућава компајлеру да реалне бројеве по потреби 
схвати као одговарајуће полиноме степена нула. Реч је о оператору имплицитне конверзије реалног 
броја у полином. Пошто се ради о имплицитној конверзији, неће бити потребе ни да у изразима у којима 
користимо класу ``Polynomial`` назначавамо када број треба да се заменимо полиномом (експлицитна 
конверзија, односно каст). Компајлер ће то сам да учини у ситуацијама у којима то разрешава конфликт 
неслагања типова, као што то чини када сабирамо целе и реалне бројеве. 

Оператор имплицитне конверзије може, на пример, да се напише овако:

.. activecode:: implicitna_konverzija_broja_u_polinom
    :passivecode: true

        public static implicit operator Polynomial(double c)
        {
            Polynomial P = new Polynomial(0);
            P.a[0] = c;
            return P;
        }

Када будемо комплетирали класу, овај оператор ће нам омогућити да у корисничком програму пишемо овакве и 
сличне наредбе:

.. activecode:: upotreba_implicitne_konverzije
    :passivecode: true
    
    Polynomial R = P + 3;
    Polynomial T = 2 * Q;
    

Исписивање полинома
'''''''''''''''''''

Да бисмо могли да исписујемо саме полиноме (а не само њихове вредности или коефицијенте) на исти 
начин као што исписујемо бројеве и податке других основних типова, можемо да редефинишемо метод 
``ToString`` за полиноме. Дефиниција тог метода изгледа овако:

.. activecode:: ispisivanje_polinoma1
    :passivecode: true

    public override string ToString()
    {
        ...
    }

У овом методу можемо да израчунамо стринг, који ће да представља наш полином. Грубо говорећи, за дати 
полином треба у стринг нанизати записе облика ``+a_i*x^i`` за све степене ``i`` и коефицијенте ``a_i``. 
Ипак, програмско исписивање полинома на начин који је уобичајен у математици је задатак који захтева 
нешто више пажње и труда, јер постоје разни изузеци од овог општег правила. На пример, ако је 
:math:`P(x)= 3x^5 +x^4 -7x^2 + 2x - 6`, не желимо да програм испише 
``+3x^5+1x^4+0x^3+-7x^2+2x^1+-6x^0``, него ``3x^5+x^4-7x^2+2x-6``. Из овог примера можемо да уочимо 
неколико додатних правила:

- Знак плус треба изоставити испред водећег коефицијента
- Када је коефицијент уз неки степен нула, цео члан треба изоставити, осим што код полинома једнаког 
  нули треба исписати укупно једну нулу
- Када је коефицијент уз неки степен један, треба изоставити коефицијент, осим ако је реч о 
  слободном коефицијенту
- Када је коефицијент уз неки степен минус један, треба писати само минус, осим ако је реч о 
  слободном коефицијенту
- Уз линеаран коефицијент не треба писати ``x^1``, него ``x``
- Уз слободан коефицијент не треба писати ``x^0``
- Када је коефицијент уз неки степен негативан, треба изоставити знак плус испред члана

Да бисмо избегли понављање делова кôда, користимо помоћну функцију ``Monomial``, која враћа текстуалну 
репрезентацију једног члана полинома, водећи рачуна о разним специјалним случајевима. У методу 
``ToString`` само позивамо метод ``Monomial``, и то једном за водећи члан, и једном у петљи за 
остале чланове. 

.. activecode:: ispisivanje_polinoma2
    :passivecode: true
    
    private string Monomial(double ai, int i, bool leading)
    {
        if (ai == 0)
            return "";

        string sign = (leading || ai < 0) ? "" : "+";
        string coef = (ai != 1 && ai != -1) ? ai.ToString() :
            (i == 0) ? ai.ToString() : "";
        string xPowI = 
            (i == 0) ? "" :
            (i == 1) ? "x" : 
            string.Format("x^{0}", i);

        return sign + coef + xPowI;
    }
    public override string ToString()
    {
        if (Deg < 0)
            return "0";

        StringBuilder sb = new StringBuilder();
        sb.Append(Monomial(a[Deg], Deg, true));
        for (int i = Deg-1; i >= 0; i--)
            sb.Append(Monomial(a[i], i, false));

        return sb.ToString();
    }

Имплементација метода ``ToString`` за полиноме, омогућава нам да у корисничком програму за дати полином 
``P`` пишемо нпр. ``Console.WriteLine("P = {0}", P);`` и добијемо исправно исписан израз полинома.

Комплетан кôд овог (као и свих других) примера може да се преузме са уводне странице овог курса.

Карацубин алгоритам
-------------------

Из уобичајеног алгоритма за множење 


.. activecode:: mnozenje_polinoma
    :passivecode: true

    public static Polynomial operator *(Polynomial P, Polynomial Q)
    {
        Polynomial R = new Polynomial(P.Deg + Q.Deg);
        for (int i = 0; i <= P.Deg; i++)
            for (int j = 0; j <= Q.Deg; j++)
                R.a[i + j] += P.a[i] * Q.a[j];

        return R;
    }

лако можемо да израчунамо број операција које се изврше у овом алгоритму. Наредба у двострукој петљи 
се извршава :math:`(deg(P) + 1) \cdot (deg(Q) + 1)` пута, а у њој имамо по једно сабирање и множење. 
Означимо степене полинома :Math:`P, Q` редом са :Math:`n, m`. Сада имамо да је број операција једнак 
:math:`f(n, m) = (n + 1) \cdot (m + 1)`, одакле за довољно велике :Math:`n, m` следи 
:math:`mn \leq f(n, m) \leq 2mn`. Користећи стандардну нотацију за сложеност алгоритма, овај закључак 
можемо да запишемо као :math:`Т(n, m) = \theta(mn)`. Једноставније речено, број операција (а тиме и 
време рада алгоритма) расте асимптотски истом брзином као и производ  :math:`mn`.

Анатолиј Карацуба је 1960. године као студент Колмогорова дошао до идеје како да рекурзивним поступком 
смањи број операција при множењу полинома, када су степени :math:`m, n` довољно велики. Да бисмо суштину 
идеје изразили што једноставније, претпоставимо да је 

.. math::

    \begin{aligned}
    P(x) = p_{2n-1}x^{2n-1}+...+p_{2}x^2+ + p_1x+p_0\\
    Q(x) = q_{2n-1}x^{2n-1}+...+q_{2}x^2+ + q_1x+q_0\\
    \end{aligned}

Тада полиноме :math:`P, Q` можемо да запишемо и овако:

.. math::

    \begin{aligned}
    P(x) &= p_{2n-1}x^{2n-1}+...+p_{n}x^{n} + p_{n-1}x^{n-1}+...+p_{0}x^{0}\\
    &= (p_{2n-1}x^{n-1}+...+p_{n})x^{n} + (p_{n-1}x^{n-1}+...+p_{0}x^{0})\\
    &= P_1 x^{n} + P_2\\
    \\
    Q(x) &= q_{2n-1}x^{2n-1}+...+q_{n}x^{n} + q_{n-1}x^{n-1}+...+q_{0}x^{0}\\
    &= (q_{2n-1}x^{n-1}+...+q_{n})x^{n} + (q_{n-1}x^{n-1}+...+q_{0}x^{0})\\
    &= Q_1 x^{n} + Q_2\\
    \end{aligned}

Приметимо да су полиноми :math:`P_1, P_2, Q_1, Q_2` степена :math:`n-1`, тј. имају по :math:`n` 
коефицијената, дакле двоструко мање коефицијената него полиноми :math:`P` и :math:`Q`. Даље имамо:

.. math::

    \begin{aligned}
    P \cdot Q &= (P_1 x^{n} + P_2) (Q_1 x^{n} + Q_2)\\
    &= (P_1 \cdot Q_1)x^{2n} + (P_1 \cdot Q_2)x^n + (P_2 \cdot Q_1)x^n + P_2 \cdot Q_2\\
    &= (P_1 \cdot Q_1)x^{2n} + (P_1 \cdot Q_2 + P_2 \cdot Q_1)x^n + P_2 \cdot Q_2\\
    &= (P_1 \cdot Q_1)x^{2n} + ((P_1+P_2)\cdot(Q_1+Q_2) - P_1 \cdot Q_1 - P_2 \cdot Q_2)x^n + P_2 \cdot Q_2\\
    &= R_1 x^{2n} + ((P_1+P_2)\cdot(Q_1+Q_2) - R_1 - R_2)x^n + R_2\\
    \end{aligned}

где је :Math:`R_1 = P_1 \cdot Q_1, R_2 = P_2 \cdot Q_2`. На основу овога, производ :Math:`P \cdot Q`, 
можемо да добијемо тако што израчунамо производе 

.. math::

    \begin{aligned}
    R_1 &= P_1 \cdot Q_1\\
    R_2 &= P_2 \cdot Q_2\\
    R_3 &= (P_1+P_2)\cdot(Q_1+Q_2)\\
    \end{aligned}
    
уз додатни број операција, који је сразмеран са :math:`n`. Другим речима, проблем множења два полинома 
са низовима коефицијената дужине :Math:`2n` сведен је на три проблема истог типа, са низовима дужине 
:Math:`n`. Због тога, за време извршавања алгоритма важи :math:`T(2n,2n)=3T(n,n)+\theta(n)`. Може 
се доказати (за доказ видети `мастер теорему <https://sr.wikipedia.org/wiki/Мастер_теорема>`_) 
да из ове рекурентне релације следи 

.. math::

    T(n,m) = \Theta (max(n,m)^{\log_{2}3})

Ово значи да је за полиноме :math:`P` и :math:`Q`, степена редом :math:`n` и :math:`m`, потребно 
приближно :math:`N^{\log_2 3} \approx N^{1.58}` операција за њихово множење Карацубиним алгоритмом, 
где је са :math:`N` означен :math:`max(n, m)`. 

На крају, ево и наше имплементације Карацубиног множења полинома:

.. activecode:: karacuba_mnozenje_polinoma
    :passivecode: true

    public static Polynomial Karatsuba(Polynomial P, Polynomial Q)
    {
        if (P.Deg <= 1 || Q.Deg <= 1) 
            return P * Q;

        int n = 1 + Math.Max(P.Deg, Q.Deg);
        int n2 = n / 2;
        Polynomial Lo1 = new Polynomial(n2 - 1);
        Polynomial Hi1 = new Polynomial(P.Deg - n2);
        Polynomial Lo2 = new Polynomial(n2 - 1);
        Polynomial Hi2 = new Polynomial(Q.Deg - n2);
        for (int i = 0; i < n2; i++)
        {
            Lo1.a[i] = P.a[i];
            Lo2.a[i] = Q.a[i];
        }
        for (int i = n2; i <= P.Deg; i++)
            Hi1.a[i - n2] = P.a[i];
        for (int i = n2; i <= Q.Deg; i++)
            Hi2.a[i - n2] = Q.a[i];

        Polynomial z0 = Karatsuba(Lo1, Lo2);
        Polynomial z2 = Karatsuba(Hi1, Hi2);
        Polynomial z1 = Karatsuba(Lo1 + Hi1, Lo2 + Hi2) - z2 - z0;
        return z0 + z1.TimesxPow(n2) + z2.TimesxPow(2 * n2);
    }

    // vraca polinom P * x^n
    private Polynomial TimesxPow(int n)
    {
        Polynomial P = new Polynomial(Deg + n);
        for (int i = Deg; i >= 0; i--)
            P.a[i + n] = a[i];

        return P;
    }


Задатак
-------

Упоредите Карацубин алгоритам за множење полинома са класичним множењем, тако што ћете у оба алгоритма 
да додате мерење времена. Испорбајте оба начина за полиноме различитих степена и покушајте да одредите 
за колико велик степен полинома Карацубин алгоритам почиње да буде бржи од класичног множења.
