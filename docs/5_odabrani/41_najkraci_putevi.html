<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="sr-Cyrl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Најкраћи путеви у графу</title>
    <link rel="stylesheet" type="text/css" href="../_static/activecode.css" />
    <link rel="stylesheet" type="text/css" href="../_static/codemirror.css" />
    <link rel="stylesheet" type="text/css" href="../_static/clickable.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pytutor.css" />
    <link rel="stylesheet" type="text/css" href="../_static/modal-basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/datafile.css" />
    <link rel="stylesheet" type="text/css" href="../_static/dragndrop.css" />
    <link rel="stylesheet" type="text/css" href="../_static/fitb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css" />
    <link rel="stylesheet" type="text/css" href="../_static/parsons.css" />
    <link rel="stylesheet" type="text/css" href="../_static/lib/prettify.css" />
    <link rel="stylesheet" type="text/css" href="../_static/poll.css" />
    <link rel="stylesheet" type="text/css" href="../_static/showEval.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabbedstuff.css" />
    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/video.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webgldemo.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webglinteractive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/karel.css" />
    <link rel="stylesheet" type="text/css" href="../_static/notes.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/associations.css" />
    <link rel="stylesheet" type="text/css" href="../_static/editor.css" />
    <link rel="stylesheet" type="text/css" href="../_static/regex-check.css" />
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/user-highlights.css" type="text/css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-4.0.0-dist/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flatly.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/petlja-course.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nbstyle.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/runestonebase.js"></script>
    <script type="text/javascript" src="../_static/skulpt.min.js"></script>
    <script type="text/javascript" src="../_static/skulpt-stdlib.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/jquery.highlight.js"></script>
    <script type="text/javascript" src="../_static/bookfuncs.js"></script>
    <script type="text/javascript" src="../_static/codemirror.js"></script>
    <script type="text/javascript" src="../_static/xml.js"></script>
    <script type="text/javascript" src="../_static/css.js"></script>
    <script type="text/javascript" src="../_static/python.js"></script>
    <script type="text/javascript" src="../_static/htmlmixed.js"></script>
    <script type="text/javascript" src="../_static/javascript.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/CLDRPluralRuleParser.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.messagestore.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.fallbacks.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.language.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.parser.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.emitter.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.emitter.bidi.js"></script>
    <script type="text/javascript" src="../_static/activecode-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/activecode-i18n.sr-Cyrl.js"></script>
    <script type="text/javascript" src="../_static/activecode.js"></script>
    <script type="text/javascript" src="../_static/clike.js"></script>
    <script type="text/javascript" src="../_static/timed_activecode.js"></script>
    <script type="text/javascript" src="../_static/animationbase.js"></script>
    <script type="text/javascript" src="../_static/mchoice.js"></script>
    <script type="text/javascript" src="../_static/timedmc.js"></script>
    <script type="text/javascript" src="../_static/timed.js"></script>
    <script type="text/javascript" src="../_static/mchoice-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/mchoice-i18n.sr-Cyrl.js"></script>
    <script type="text/javascript" src="../_static/clickable.js"></script>
    <script type="text/javascript" src="../_static/timedclickable.js"></script>
    <script type="text/javascript" src="../_static/d3.v2.min.js"></script>
    <script type="text/javascript" src="../_static/jquery.ba-bbq.min.js"></script>
    <script type="text/javascript" src="../_static/jquery.jsPlumb-1.3.10-all-min.js"></script>
    <script type="text/javascript" src="../_static/pytutor.js"></script>
    <script type="text/javascript" src="../_static/codelens.js"></script>
    <script type="text/javascript" src="../_static/skulpt.min.js"></script>
    <script type="text/javascript" src="../_static/skulpt-stdlib.js"></script>
    <script type="text/javascript" src="../_static/datafile.js"></script>
    <script type="text/javascript" src="../_static/dragndrop.js"></script>
    <script type="text/javascript" src="../_static/timeddnd.js"></script>
    <script type="text/javascript" src="../_static/dragndrop-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/dragndrop-i18n.sr-Cyrl.js"></script>
    <script type="text/javascript" src="../_static/fitb.js"></script>
    <script type="text/javascript" src="../_static/timedfitb.js"></script>
    <script type="text/javascript" src="../_static/fitb-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/fitb-i18n.sr-Cyrl.js"></script>
    <script type="text/javascript" src="../_static/matrixeq.js"></script>
    <script type="text/javascript" src="../_static/lib/prettify.js"></script>
    <script type="text/javascript" src="../_static/lib/hammer.min.js"></script>
    <script type="text/javascript" src="../_static/parsons.js"></script>
    <script type="text/javascript" src="../_static/parsons-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/parsons-i18n.sr-Cyrl.js"></script>
    <script type="text/javascript" src="../_static/timedparsons.js"></script>
    <script type="text/javascript" src="../_static/poll.js"></script>
    <script type="text/javascript" src="../_static/reveal.js"></script>
    <script type="text/javascript" src="../_static/shortanswer.js"></script>
    <script type="text/javascript" src="../_static/timed_shortanswer.js"></script>
    <script type="text/javascript" src="../_static/showEval.js"></script>
    <script type="text/javascript" src="../_static/tabbedstuff.js"></script>
    <script type="text/javascript" src="../_static/runestonevideo.js"></script>
    <script type="text/javascript" src="../_static/webglinteractive.js"></script>
    <script type="text/javascript" src="../_static/FileSaver.min.js"></script>
    <script type="text/javascript" src="../_static/Blob.js"></script>
    <script type="text/javascript" src="../_static/karelCorner.js"></script>
    <script type="text/javascript" src="../_static/karelRobot.js"></script>
    <script type="text/javascript" src="../_static/karelWorld.js"></script>
    <script type="text/javascript" src="../_static/karelRobotDrawer.js"></script>
    <script type="text/javascript" src="../_static/karelUI.js"></script>
    <script type="text/javascript" src="../_static/karel.js"></script>
    <script type="text/javascript" src="../_static/karel-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/karel-i18n.sr-Cyrl.js"></script>
    <script type="text/javascript" src="../_static/notes.js"></script>
    <script type="text/javascript" src="../_static/pygamelib-init.js"></script>
    <script type="text/javascript" src="../_static/gallery.js"></script>
    <script type="text/javascript" src="../_static/associations.js"></script>
    <script type="text/javascript" src="../_static/associations-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/associations-i18n.sr-Cyrl.js"></script>
    <script type="text/javascript" src="../_static/editor.js"></script>
    <script type="text/javascript" src="../_static/jszip.js"></script>
    <script type="text/javascript" src="../_static/editor-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/editor-i18n.sr-Cyrl.js"></script>
    <script type="text/javascript" src="../_static/regex-check.js"></script>
    <script type="text/javascript" src="../_static/regex-check-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/regex-check-i18n.sr-Cyrl.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/jquery-ui-1.10.3.custom.min.js"></script>
    <script type="text/javascript" src="../_static/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-4.0.0-dist/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-4.0.0-dist/js/bootstrap.bundle.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <script type="text/javascript" src="../_static/waypoints.min.js"></script>
    <script type="text/javascript" src="../_static/rangy-core.js"></script>
    <script type="text/javascript" src="../_static/rangy-textrange.js"></script>
    <script type="text/javascript" src="../_static/rangy-cssclassapplier.js"></script>
    <script type="text/javascript" src="../_static/user-highlights.js"></script>
    <script type="text/javascript" src="../_static/jquery.idle-timer.js"></script>
    <script type="text/javascript" src="../_static/processing-1.4.1.min.js"></script>
    <script type="text/javascript" src="../_static/jquery.hotkey.js"></script>
    <script type="text/javascript" src="../_static/jquery-migrate-1.2.1.min.js"></script>
    <script type="text/javascript" src="../_static/course-errors.js"></script>
    <script type="text/javascript" src="../_static/petlja.js"></script>
    <script type="text/javascript" src="../_static/require.js"></script>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
    <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
    <link rel="shortcut icon" href="../_static/favicon.ico" type="image/ico" />
    <script type="text/javascript">
      eBookConfig = {};
      eBookConfig.host = 'http://127.0.0.1:8000' ? 'http://127.0.0.1:8000' : 'http://127.0.0.1:8000';
      eBookConfig.app = eBookConfig.host + '/runestone';
      eBookConfig.ajaxURL = eBookConfig.app + '/ajax/';
      eBookConfig.course = 'prog3_it';
      eBookConfig.logLevel = '0';
      eBookConfig.loginRequired = 'false';
      eBookConfig.build_info = "";
      eBookConfig.isLoggedIn = false;
      eBookConfig.useRunestoneServices = false;
      eBookConfig.python3 = true;
      eBookConfig.basecourse = 'prog3_it';
      eBookConfig.runestone_version = '';
      eBookConfig.imagesDir = '../_images/';
      eBookConfig.staticDir = '../_static/';
      if (typeof (Sk) != "undefined")
        Sk.imgPath = eBookConfig.imagesDir;
    </script>

  </head>

  <body>



<div id="navbar" class="content-header">
  <div class="right-side-nav">
    
    <div id="usefulLinksToggle" class="useful-links-toggle">
        <a class="dropdown-toggle dropdown-toggle-burger" role="button" href="#" id="usefulLinksDropdown" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-bars fa-2x"></i>
        </a>
        <div class="dropdown-menu dropdown-nav-links shadow-lg" aria-labelledby="usefulLinksDropdown" x-placement="bottom-start" style="position: absolute; transform: translate3d(-55px, 32px, 0px); top: 0px; left: 0px; will-change: transform;">
          <div class="links-title"> Корисни линкови</div>
          <div class="useful-link">
            <a href="https://petlja.org/biblioteka/r/kursevi/Zbirka3" target="_blank">Методичка збирка задатака из алгоритмике - одабрани алгоритми и структуре података</a></div>
          
        </div>
    </div>

    
</div>

<div class="left-side-nav">
  <div class="course-logo-nav">
      <a target="_blank" href="https://petlja.org">
          <img src="../_static/img/petlja-logo-wt.svg" alt="petlja.org" id="lightPetljaLogo">
      </a>
  </div>
  <div class="course-logo-nav-kabinet">
      <a target="_blank" href="https://petlja.org/net.kabinet">
          <img src="../_static/img/netkabinet-logo-strelica-wt.svg" alt="petlja.org" id="lightNetKabinetLogo">
      </a>
  </div>
</div>


<div class="content-header-label" id = "content-header-label" href="../">Програмирање 3</div>

</div>




<div class="petljaCourseContainer">

<div class="petljaCourseContent">
  
           <div class="tableOfContent">
            <h5> Садржај </h5>
            </div>
           <div>
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-1_algebarski>
                    <h5>1. Основни алгебарски алгоритми</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../1_algebarski/01_alg_uvod.html><div class="studioLecture" id=activity-01_alg_uvod><i class="fas fa-file-alt activity-icon"></i>1.1 Увод</div></a>
                <a href=../1_algebarski/02_test_primalnosti.html><div class="studioLecture" id=activity-02_test_primalnosti><i class="fas fa-file-alt activity-icon"></i>1.2 Тест прималности</div></a>
                <a href=../1_algebarski/02b_test_primalnosti_quiz.html><div class="studioLecture" id=activity-02b_test_primalnosti_quiz><i class="far fa-question-circle activity-icon"></i>Тест прималности - квиз</div></a>
                <a href=../1_algebarski/Прости%20бројеви%20-%20задаци.html><div class="studioLecture" id=activity-Прости%20бројеви%20-%20задаци><i class="far fa-question-circle activity-icon"></i>Прости бројеви - задаци</div></a>
                <a href=../1_algebarski/03_faktorizacija.html><div class="studioLecture" id=activity-03_faktorizacija><i class="fas fa-file-alt activity-icon"></i>1.3 Факторизација броја</div></a>
                <a href=../1_algebarski/03b_faktorizacija_quiz.html><div class="studioLecture" id=activity-03b_faktorizacija_quiz><i class="far fa-question-circle activity-icon"></i>Факторизација броја - квиз</div></a>
                <a href=../1_algebarski/Факторизација%20броја%20-%20задаци.html><div class="studioLecture" id=activity-Факторизација%20броја%20-%20задаци><i class="far fa-question-circle activity-icon"></i>Факторизација броја - задаци</div></a>
                <a href=../1_algebarski/04_nzd.html><div class="studioLecture" id=activity-04_nzd><i class="fas fa-file-alt activity-icon"></i>1.4 Највећи заједнички делилац</div></a>
                <a href=../1_algebarski/04b_nzd_quiz.html><div class="studioLecture" id=activity-04b_nzd_quiz><i class="far fa-question-circle activity-icon"></i>Највећи заједнички делилац - квиз</div></a>
                <a href=../1_algebarski/НЗД%20и%20НЗС%20-%20задаци.html><div class="studioLecture" id=activity-НЗД%20и%20НЗС%20-%20задаци><i class="far fa-question-circle activity-icon"></i>НЗД и НЗС - задаци</div></a>
                <a href=../1_algebarski/05_prosti_do_n.html><div class="studioLecture" id=activity-05_prosti_do_n><i class="fas fa-file-alt activity-icon"></i>1.5 Одређивање свих простих бројева до дате границе</div></a>
                <a href=../1_algebarski/05b_prosti_do_n_quiz.html><div class="studioLecture" id=activity-05b_prosti_do_n_quiz><i class="far fa-question-circle activity-icon"></i>Ератостеново сито - квиз</div></a>
                <a href=../1_algebarski/Ератостеново%20сито%20-%20задаци.html><div class="studioLecture" id=activity-Ератостеново%20сито%20-%20задаци><i class="far fa-question-circle activity-icon"></i>Ератостеново сито - задаци</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-2_geometrijski>
                    <h5>2. Основни геометријски алгоритми</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../2_geometrijski/01_geom_uvod.html><div class="studioLecture" id=activity-01_geom_uvod><i class="fas fa-file-alt activity-icon"></i>2.1 Увод</div></a>
                <a href=../2_geometrijski/02_bounding_boxes.html><div class="studioLecture" id=activity-02_bounding_boxes><i class="fas fa-file-alt activity-icon"></i>2.2 Поравнати правоугаоници</div></a>
                <a href=../2_geometrijski/02b_bounding_boxes_quiz.html><div class="studioLecture" id=activity-02b_bounding_boxes_quiz><i class="far fa-question-circle activity-icon"></i>Поравнати правоугаоници - квиз</div></a>
                <a href=../2_geometrijski/03_tacke_i_vektori.html><div class="studioLecture" id=activity-03_tacke_i_vektori><i class="fas fa-file-alt activity-icon"></i>2.3 Тачке и вектори</div></a>
                <a href=../2_geometrijski/04_orijentacija_trojke_tacaka.html><div class="studioLecture" id=activity-04_orijentacija_trojke_tacaka><i class="fas fa-file-alt activity-icon"></i>2.4 Оријентација тројке тачака</div></a>
                <a href=../2_geometrijski/04b_odnosi_tacaka_i_vektora_quiz.html><div class="studioLecture" id=activity-04b_odnosi_tacaka_i_vektora_quiz><i class="far fa-question-circle activity-icon"></i>Односи тачака и вектора - квиз</div></a>
                <a href=../2_geometrijski/05_obimi_i_povrsine.html><div class="studioLecture" id=activity-05_obimi_i_povrsine><i class="fas fa-file-alt activity-icon"></i>2.5 Обими и површине многоуглова</div></a>
                <a href=../2_geometrijski/05b_obimi_i_povrsine_quiz.html><div class="studioLecture" id=activity-05b_obimi_i_povrsine_quiz><i class="far fa-question-circle activity-icon"></i>Обими и површине многоуглова - квиз</div></a>
                <a href=../2_geometrijski/06_vizuelizacija.html><div class="studioLecture" id=activity-06_vizuelizacija><i class="fas fa-file-alt activity-icon"></i>2.6 Визуелизација</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-3_tekstualni>
                    <h5>3. Основни алгоритми текста</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../3_tekstualni/00_uvod.html><div class="studioLecture" id=activity-00_uvod><i class="fas fa-file-alt activity-icon"></i>3.1 Увод</div></a>
                <a href=../3_tekstualni/01a_stringovi_metodi_pregled.html><div class="studioLecture" id=activity-01a_stringovi_metodi_pregled><i class="fas fa-file-alt activity-icon"></i>3.2 Методи за рад са стринговима</div></a>
                <a href=../3_tekstualni/01b_poredjenjе_stringova.html><div class="studioLecture" id=activity-01b_poredjenjе_stringova><i class="fas fa-file-alt activity-icon"></i>3.2.1 Поређење стрингова</div></a>
                <a href=../3_tekstualni/01c_pretrazivanje_stringova.html><div class="studioLecture" id=activity-01c_pretrazivanje_stringova><i class="fas fa-file-alt activity-icon"></i>3.2.2 Претраживање и провера постојања садржаја стринга</div></a>
                <a href=../3_tekstualni/01d_transformisanje_stringova.html><div class="studioLecture" id=activity-01d_transformisanje_stringova><i class="fas fa-file-alt activity-icon"></i>3.2.3 Трансформисање стрингова</div></a>
                <a href=../3_tekstualni/01e_stringovi_metodi_quiz.html><div class="studioLecture" id=activity-01e_stringovi_metodi_quiz><i class="far fa-question-circle activity-icon"></i>Методи за рад са стринговима - квиз</div></a>
                <a href=../3_tekstualni/01f_stringovi_zadaci.html><div class="studioLecture" id=activity-01f_stringovi_zadaci><i class="fas fa-file-alt activity-icon"></i>Стрингови - задаци</div></a>
                <a href=../3_tekstualni/02a_regularni_izrazi.html><div class="studioLecture" id=activity-02a_regularni_izrazi><i class="fas fa-file-alt activity-icon"></i>3.3.1 Регуларни изрази</div></a>
                <a href=../3_tekstualni/02b_slozeniji_izrazi.html><div class="studioLecture" id=activity-02b_slozeniji_izrazi><i class="fas fa-file-alt activity-icon"></i>3.3.2 Сложенији регуларни изрази</div></a>
                <a href=../3_tekstualni/02c_regexi_quiz.html><div class="studioLecture" id=activity-02c_regexi_quiz><i class="far fa-question-circle activity-icon"></i>Регуларни изрази - квиз</div></a>
                <a href=../3_tekstualni/02d_regexi_u_programima.html><div class="studioLecture" id=activity-02d_regexi_u_programima><i class="fas fa-file-alt activity-icon"></i>3.3.3 Регуларни изрази у програмима</div></a>
                <a href=../3_tekstualni/02e_regexi_zadaci.html><div class="studioLecture" id=activity-02e_regexi_zadaci><i class="fas fa-file-alt activity-icon"></i>Регуларни изрази - задаци</div></a>
                <a href=../3_tekstualni/03_parsiranje_rekurzivni_spust.html><div class="studioLecture" id=activity-03_parsiranje_rekurzivni_spust><i class="fas fa-file-alt activity-icon"></i>3.4 Парсирање и рекурзивни спуст</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-4_grafovski>
                    <h5>4. Основни графовски алгоритми</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../4_grafovski/00_grafovi_uvod.html><div class="studioLecture" id=activity-00_grafovi_uvod><i class="fas fa-file-alt activity-icon"></i>4.1 Увод</div></a>
                <a href=../4_grafovski/01_primeri_grafova.html><div class="studioLecture" id=activity-01_primeri_grafova><i class="fas fa-file-alt activity-icon"></i>4.2 Примери графова</div></a>
                <a href=../4_grafovski/01b_primeri_grafova_kviz.html><div class="studioLecture" id=activity-01b_primeri_grafova_kviz><i class="far fa-question-circle activity-icon"></i>Примери графова - квиз</div></a>
                <a href=../4_grafovski/02_definicije_grafova.html><div class="studioLecture" id=activity-02_definicije_grafova><i class="fas fa-file-alt activity-icon"></i>4.3 Дефиниције појмова у вези са графовима</div></a>
                <a href=../4_grafovski/02b_definicije_grafova_kviz.html><div class="studioLecture" id=activity-02b_definicije_grafova_kviz><i class="far fa-question-circle activity-icon"></i>Дефиниције појмова у вези са графовима - квиз</div></a>
                <a href=../4_grafovski/03_predstavljanje_grafova.html><div class="studioLecture" id=activity-03_predstavljanje_grafova><i class="fas fa-file-alt activity-icon"></i>4.4 Представљање графова</div></a>
                <a href=../4_grafovski/03b_predstavljanje_grafova_kviz.html><div class="studioLecture" id=activity-03b_predstavljanje_grafova_kviz><i class="far fa-question-circle activity-icon"></i>Представљање графова у рачунару - квиз</div></a>
                <a href=../4_grafovski/Представљање%20графова%20-%20задаци%20за%20самостални%20рад.html><div class="studioLecture" id=activity-Представљање%20графова%20-%20задаци%20за%20самостални%20рад><i class="far fa-question-circle activity-icon"></i>Представљање графова - задаци за самостални рад</div></a>
                <a href=../4_grafovski/04_obilazak_grafa.html><div class="studioLecture" id=activity-04_obilazak_grafa><i class="fas fa-file-alt activity-icon"></i>4.5 Обилазак графова</div></a>
                <a href=../4_grafovski/04b_obilazak_grafa_kviz.html><div class="studioLecture" id=activity-04b_obilazak_grafa_kviz><i class="far fa-question-circle activity-icon"></i>Обилазак графова - квиз</div></a>
                <a href=../4_grafovski/04_obilazak_grafa_zadaci.html><div class="studioLecture" id=activity-04_obilazak_grafa_zadaci><i class="fas fa-file-alt activity-icon"></i>Обилазак графова - решени задаци</div></a>
                <a href=../4_grafovski/Обилазак%20графова%20-%20задаци%20за%20самостални%20рад.html><div class="studioLecture" id=activity-Обилазак%20графова%20-%20задаци%20за%20самостални%20рад><i class="far fa-question-circle activity-icon"></i>Обилазак графова - задаци за самостални рад</div></a>
                <a href=../4_grafovski/05_povezane_komponente.html><div class="studioLecture" id=activity-05_povezane_komponente><i class="fas fa-file-alt activity-icon"></i>4.6 Компоненте повезаности</div></a>
                <a href=../4_grafovski/Компоненте%20повезаности%20-%20задаци%20за%20самостални%20рад.html><div class="studioLecture" id=activity-Компоненте%20повезаности%20-%20задаци%20за%20самостални%20рад><i class="far fa-question-circle activity-icon"></i>Компоненте повезаности - задаци за самостални рад</div></a>
                <a href=../4_grafovski/06_topolosko_sortiranje.html><div class="studioLecture" id=activity-06_topolosko_sortiranje><i class="fas fa-file-alt activity-icon"></i>4.7 Тополошко сортирање</div></a>
                <a href=../4_grafovski/Тополошко%20сортирање%20-%20задаци%20за%20самостални%20рад.html><div class="studioLecture" id=activity-Тополошко%20сортирање%20-%20задаци%20за%20самостални%20рад><i class="far fa-question-circle activity-icon"></i>Тополошко сортирање - задаци за самостални рад</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-5_odabrani>
                    <h5>5. Одабрани алгоритми и структуре података</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../5_odabrani/0_uvod.html><div class="studioLecture" id=activity-0_uvod><i class="fas fa-file-alt activity-icon"></i>Увод</div></a>
                <a href=../5_odabrani/11_prosireni_euklidov_alg.html><div class="studioLecture" id=activity-11_prosireni_euklidov_alg><i class="fas fa-file-alt activity-icon"></i>5.1.1 Проширени Еуклидов алгоритам</div></a>
                <a href=../5_odabrani/Проширени%20Еуклидов%20алгоритам%20-%20задаци.html><div class="studioLecture" id=activity-Проширени%20Еуклидов%20алгоритам%20-%20задаци><i class="far fa-question-circle activity-icon"></i>Проширени Еуклидов алгоритам - задаци</div></a>
                <a href=../5_odabrani/12_racunanje_sa_polinomima.html><div class="studioLecture" id=activity-12_racunanje_sa_polinomima><i class="fas fa-file-alt activity-icon"></i>5.1.2 Рачунање са полиномима</div></a>
                <a href=../5_odabrani/13_algebarski_dalje.html><div class="studioLecture" id=activity-13_algebarski_dalje><i class="fas fa-file-alt activity-icon"></i>5.1.3 Још неки алгебарски алгоритми</div></a>
                <a href=../5_odabrani/21_konveksan_omotac.html><div class="studioLecture" id=activity-21_konveksan_omotac><i class="fas fa-file-alt activity-icon"></i>5.2.1 Конвексан омотач</div></a>
                <a href=../5_odabrani/23_pripadnost_prostom_mnogouglu.html><div class="studioLecture" id=activity-23_pripadnost_prostom_mnogouglu><i class="fas fa-file-alt activity-icon"></i>5.2.2 Припадност простом многоуглу</div></a>
                <a href=../5_odabrani/24_geometrijski_dalje.html><div class="studioLecture" id=activity-24_geometrijski_dalje><i class="fas fa-file-alt activity-icon"></i>5.2.3 Још неки геометријски алгоритми</div></a>
                <a href=../5_odabrani/31_pretraga_podniske.html><div class="studioLecture" id=activity-31_pretraga_podniske><i class="fas fa-file-alt activity-icon"></i>5.3.1 Алгоритми претраге подниске</div></a>
                <a href=../5_odabrani/32_json_yaml.html><div class="studioLecture" id=activity-32_json_yaml><i class="fas fa-file-alt activity-icon"></i>5.3.2 Формати JSON и YAML</div></a>
                <a href=../5_odabrani/33_markdown.html><div class="studioLecture" id=activity-33_markdown><i class="fas fa-file-alt activity-icon"></i>5.3.3 Формат Markdown</div></a>
                <a href=../5_odabrani/34_tekstualni_dalje.html><div class="studioLecture" id=activity-34_tekstualni_dalje><i class="fas fa-file-alt activity-icon"></i>5.3.4 Још неки алгоритми са текстом</div></a>
                <a href=../5_odabrani/41_najkraci_putevi.html><div class="studioLecture" id=activity-41_najkraci_putevi><i class="fas fa-file-alt activity-icon"></i>5.4.1 Најкраћи путеви у графу</div></a>
                <a href=../5_odabrani/42_min_razapinjuce_drvo.html><div class="studioLecture" id=activity-42_min_razapinjuce_drvo><i class="fas fa-file-alt activity-icon"></i>5.4.2 Минимално разапињуће дрво</div></a>
                <a href=../5_odabrani/43_grafovski_dalje.html><div class="studioLecture" id=activity-43_grafovski_dalje><i class="fas fa-file-alt activity-icon"></i>5.4.3 Још неки графовски алгоритми</div></a>
                </div>
            </div>
                </div>
</div>



<div class="lectureContent">

  <div id="errors">
  </div>
  
  <div class="lectureContentMaterial">
  
    <div id="main-content">
    
  <div class="section" id="id1">
<h1>Најкраћи путеви у графу<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Већ смо видели да тежински графови могу да представе мрежу
путева. Питања која се природно постављају над таквим графовима су
одређивање најкраћих путева. Можемо разматрати следеће задатке:</p>
<ul class="simple">
<li><p>Одредити најкраћи пут измећу чворова A и Б;</p></li>
<li><p>Одредити најкраће путеве између чвора А и свих осталих чворова у
графу (енгл. single source shortest paths);</p></li>
<li><p>Одредити најкраће путеве између свих парова чворова у графу
(енгл. all-pairs shortest paths).</p></li>
</ul>
<p>Приликом решавања ових задатака често се претпоставља да су растојања
између чворова (тј. тежине грана у графу) ненегативни бројеви. Ако најкраћи
пут између чворова A и Б пролази преко чвора Ц, тада се он састоји од
најкраћег пута од А до Ц и најкраћег пута од Ц до Б (у супротном би
неки од та два пута могао да буде скраћен, па би био скраћен и пут од
А до Б, што није могуће). То значи да је скоро немогуће одредити
најкраћи пут од чвора A до чвора Б, не разматрајући најкраће путеве до
осталих чворова. Стога се први наведени проблем често своди на други и
најкраћи пут између чворова А и Б се одређује тако што се одређују
најкраћи путеви између чвора А и осталих чворова, све док се не одреди
најкраћи пут до траженог чвора Б. Трећи проблем је могуће свести на
други тј. најкраће путеве између свих парова чворова је могуће
одредити тако што се за сваки чвор одреде најкраћи путеви до остлаих
чворова. Ипак, постоји и директан алгоритам којим се ефикасно и
једноставно решава трећи наведени проблем. Стога ћемо у наставку
разматрати:</p>
<ul class="simple">
<li><p><strong>Дајкстрин алгоритам</strong> за одређивање најкраћих путева од чвора А до
свих осталих чворова у графу, у коме нема негативних тежина;</p></li>
<li><p><strong>Флојд-Варшалов алгоритам</strong> за одређивање најкраћих путева између
свих парова чворова у графу у коме нема циклуса негативне тежине.</p></li>
</ul>
<p>Поред Дајкстриног алгоритма, за одређивање најкраћих путева из једног
чвора користи се и Белман-Фордов алгоритам (он ради и када у графу
постоје гране негативне тежине), а за одређивање најкраћих путева
између свих парова чворова користи се и Џонсонов алгоритам.</p>
<div class="section" id="id2">
<h2>Најкраћи путеви из једног чвора - Дајкстрин алгоритам<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Дајкстрин алгоритам одређује најкраће растојање од неког фиксног чвора
<span class="math notranslate nohighlight">\(v_0\)</span> до свих осталих чворова у графу. Основна идеја алгоритма
је да се ти чворови обилазе у редоследу најкраћих растојања од
полазног чвора.</p>
<p>Алгоритам ради индуктивно, тако што се претпоставља да се након
<span class="math notranslate nohighlight">\(k\)</span> корака извршавања алгоритма познају <span class="math notranslate nohighlight">\(k\)</span> чворова који
су најближи почетном чвору (укључујући и њега), као и најкраћа
растојања од почетног чвора до њих. Нека они чине скуп чворова
<span class="math notranslate nohighlight">\(V_k = \{v_0, \ldots, v_{k-1}\}\)</span>. Почетни чвор је сигурно
најближи сам себи и растојање до њега је једнако нули, па је база
индукције скуп <span class="math notranslate nohighlight">\(V_1 = \{v_0\}\)</span> који садржи само почетни
чвор. Поставља се питање како извршити идуктивни корак тј. како да се
одреди наредни најближи чвор <span class="math notranslate nohighlight">\(v_{k}\)</span>. Најкраћи пут од почетног
чвора <span class="math notranslate nohighlight">\(v_0\)</span> до чвора <span class="math notranslate nohighlight">\(v_k\)</span> може да садржи само чворове из
<span class="math notranslate nohighlight">\(V_k\)</span> (на том путу не може постојати неки чвор ван <span class="math notranslate nohighlight">\(V_k\)</span>,
јер би тај чвор био ближи почетном чвору од чвора <span class="math notranslate nohighlight">\(v_k\)</span>). Према
томе, да бисмо пронашли чвор <span class="math notranslate nohighlight">\(v_k\)</span>, треба проверити све гране
које спајају чворове из <span class="math notranslate nohighlight">\(V_k\)</span> са чворовима који нису у
<span class="math notranslate nohighlight">\(V_k\)</span> (остале гране се могу ингорисати). У сваком кораку се скуп
<span class="math notranslate nohighlight">\(V_k\)</span> проширује чвором <span class="math notranslate nohighlight">\(v_k \notin V_k\)</span> за који је најмања
вредност <span class="math notranslate nohighlight">\(\min\{r(v_0, v_i) + d(v_i, v_k)\ |\ v_i \in V_k\}\)</span>,
где је <span class="math notranslate nohighlight">\(r(v_0, v_i)\)</span> дужина најкраћег пута од почетног чвора
<span class="math notranslate nohighlight">\(v_0\)</span> до <span class="math notranslate nohighlight">\(v_i\)</span> (који је познат на основу индуктивне
хипотезе), а <span class="math notranslate nohighlight">\(d(v_i, v_k)\)</span> дужина гране од чвора <span class="math notranslate nohighlight">\(v_i\)</span> до
<span class="math notranslate nohighlight">\(v_k\)</span>.</p>
<p>Овим је алгоритам у потпуности прецизиран и могуће је дати опис
алгоритма у пседукоду. Вредности <span class="math notranslate nohighlight">\(r(v_0, v_i)\)</span> најкраћих
растојања за чворове <span class="math notranslate nohighlight">\(v_i\)</span> скупа <span class="math notranslate nohighlight">\(V_k\)</span> које су већ
одређене се памте у низу <code class="docutils literal notranslate"><span class="pre">r</span></code> и обележавамо их са <code class="docutils literal notranslate"><span class="pre">r[vi]</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>postavi Vk={v0}
postavi najkrace rastojanje r[v0] = 0
dok skup Vk ne sadrzi sve cvorove grafa:
    odaberi par corova vi ∈ Vk i vk ∉ Vk za koji se postiže
       najmanja vrednost r[vi] + d(vi, vk)
    ubaci cvor vk u Vk
    postavi najkrace rastojanje r[vk] = r[vi] + d(vi, vk)
za svaki cvor vi najkrace rastojanje je r[vi]
</pre></div>
</div>
<p>Значајна неефикасност претходног алгоритма настаје због анализе свих
парова чворова <span class="math notranslate nohighlight">\((v_i, v_k)\)</span> у сваком кораку. Ефикаснија
имплементација се може добити ако се за сваки чвор <span class="math notranslate nohighlight">\(v\)</span> ван
<span class="math notranslate nohighlight">\(V_k\)</span> у једном низу памти вредност</p>
<div class="math notranslate nohighlight">
\[r_v = \min\{r(v_0, v_i) + d(v_i, v)\ |\ v_i \in V_k\}\]</div>
<p>која процењује најкраће растојање од чвора <span class="math notranslate nohighlight">\(v_0\)</span> до чвора
<span class="math notranslate nohighlight">\(v\)</span> (али само преко чворова из <span class="math notranslate nohighlight">\(V_k\)</span>). За чворове који
нису достижни на овај начин, у низу се памти вредност <span class="math notranslate nohighlight">\(r_v =
+\infty\)</span>, док за чворове <span class="math notranslate nohighlight">\(v_i \in V_k\)</span> важи да је <span class="math notranslate nohighlight">\(r_{v_i}
= r(v_0, v_i)\)</span> тј. у низу се памте стварне вредности најкраћих
растојања од <span class="math notranslate nohighlight">\(v_0\)</span>.</p>
<p>Вредност <span class="math notranslate nohighlight">\(r_v\)</span> се може израчунавати инкрементално. Када се нови
чвор дода у <span class="math notranslate nohighlight">\(V_k\)</span> потребно је ажурирати само вредности
<span class="math notranslate nohighlight">\(r_v\)</span> њему суседних чворова. Претпоставимо да се у скуп
<span class="math notranslate nohighlight">\(V_k\)</span> додаје чвор <span class="math notranslate nohighlight">\(v_k\)</span> и тако добија <span class="math notranslate nohighlight">\(V_{k+1}\)</span>. За
сваки чвор <span class="math notranslate nohighlight">\(v\)</span> суседан чвору <span class="math notranslate nohighlight">\(v_k\)</span> нова вредност
<span class="math notranslate nohighlight">\(r'_v\)</span> једнака је</p>
<div class="math notranslate nohighlight">
\[r_v' = \min\{r_v, r(v_0, v_k) + d(v_k, v)\} = \min\{r_v, r_{v_k} + d(v_k, v)\}.\]</div>
<p>Заиста, пошто је <span class="math notranslate nohighlight">\(V_{k+1} = V_k \cup \{v_k\}\)</span> важи да је</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray*}
 r_v' = \min\{r(v_0, v_i) + d(v_i, v)\ |\ v_i \in V_{k+1}\} &amp;=&amp;\\
 \min\{r(v_0, v_i) + d(v_i, v)\ |\ v_i \in V_{k} \vee v_i = v_k\} &amp;=&amp;\\
 \min\{\min\{r(v_0, v_i) + d(v_i, v)\ |\ v_i \in V_{k}\}, r(v_0, v_k) + d(v_k, v)\} &amp;=&amp;\\
 \min\{r_v, r_{v_k} + d(v_k, v)\}
\end{eqnarray*}\end{split}\]</div>
<p>Ова модификација се описује следећим псеудокодом (у претходном
алгоритму низ <span class="math notranslate nohighlight">\(r\)</span> је садржао само најкраћа растојања до чворова
у <span class="math notranslate nohighlight">\(V_k\)</span>, а у овом поред тога садржи и процене најкраћих
растојања до чворова ван <span class="math notranslate nohighlight">\(V_k\)</span> које пролазе само преко чворова
из <span class="math notranslate nohighlight">\(V_k\)</span>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>postavi r[v0]=0 i r[vi]=∞ za ostale cvorove vi
postavi Vk={v0}
dok skup Vk ne sadrzi sve cvorove grafa:
    odaberi k takvo da vk nije u Vk, za koje se postiže najmanja vrednost r[k]
    ubaci cvor vk u Vk
    za sve susede vj cvora vk:
       postavi r[vj] na min(r[vj], r[vk] + d(vk, vj))
za svaki cvor vi najkrace rastojanje je r[vi]
</pre></div>
</div>
<p>У наредној анимацији је приказан рад овог алгоритма на једном примеру.
Свака врста табеле са десне стране садржи тренутну процену растојања
сваког чвора од почетног (почетни је чвор 0) и те процене се мало по
мало приближавају стварним вредностима најкраћих растојања од почетног
чвора. Чворови скупа <span class="math notranslate nohighlight">\(V_k\)</span> су обојени зеленом бојом.</p>

    <div class="gallery" id="dajkstra_1">
        <div>
            <div style="width: 800px;height:100%">
            <img src="../_images/dajkstra1_1.png" width="100%" height="100%">
<img src="../_images/dajkstra1_2.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_3.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_4.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_5.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_6.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_7.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_8.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_9.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_10.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_11.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_12.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_13.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_14.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_15.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_16.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_17.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_18.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_19.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_20.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_21.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_22.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra1_23.png" width="100%" height="100%" style="display: none;">



            </div>
        </div>
    </div>
    <div class="nav-gallery row" id="dajkstra_1-nav">
        <div class="prev-img">
        &#10094;
        </div>
        <div class="next-img">
        <span class="float-right">&#10095;</span>
        </div>
    </div>
<p>Ова анимација је креирана коришћењем веб-апликације доступне на сајту
Математичког факултета у Београду
(<a class="reference external" href="http://www.matf.bg.ac.rs/~filip/algoritmi/dajkstra.html">http://www.matf.bg.ac.rs/~filip/algoritmi/dajkstra.html</a>). Покушај да
коришћењем ове апликације тестираш своје досадашње разумевање алгоритма
(за граф који ти буде приказан попуни таблицу, па провери да ли си је
добро попунио/попунила)</p>
<p>У наставку дајемо опис алгоритма у оригиналном облику (онако како га
је описао Дајкстра). У сваком кораку алгоритма скуп чворова је подељен
на:</p>
<ul class="simple">
<li><p>скуп <span class="math notranslate nohighlight">\(A\)</span> који садржи чворове до којих је познато најкраће
растојање (то је скуп <span class="math notranslate nohighlight">\(V_k\)</span> из претходног описа) и</p></li>
<li><p>скуп <span class="math notranslate nohighlight">\(B\)</span> који садржи чворове до којих још није познато
најкраће растојање.</p></li>
</ul>
<p>Скуп <span class="math notranslate nohighlight">\(B\)</span> се може поделити на скуп <span class="math notranslate nohighlight">\(B_1\)</span> који садржи
чворове који су помоћу једне гране повезани са чворовима из скупа
<span class="math notranslate nohighlight">\(A\)</span> и скуп <span class="math notranslate nohighlight">\(B_2\)</span> који садржи остале чворове скупа
<span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>Скуп грана се у сваком кораку алгоритма може разложити на:</p>
<ul class="simple">
<li><p>скуп <span class="math notranslate nohighlight">\(I\)</span> који садржи гране на најкраћим путевима од почетног
чвора до чворова из скупа <span class="math notranslate nohighlight">\(A\)</span> (те гране су у претходној
анимацији обојене зелено)</p></li>
<li><p>скуп <span class="math notranslate nohighlight">\(II\)</span> који повезује чворове из скупа <span class="math notranslate nohighlight">\(A\)</span> са
чворовима из скупа <span class="math notranslate nohighlight">\(B_1\)</span> – за сваки чвор из <span class="math notranslate nohighlight">\(B_1\)</span> овај
скуп садржи тачно једну грану и то ону која даје најкраћи пут до тог
чвора узевши у обзир све чворове из <span class="math notranslate nohighlight">\(A\)</span> (те гране су у
претходној анимацији обојене наранџасто).</p></li>
<li><p>скуп <span class="math notranslate nohighlight">\(III\)</span> који садржи остале гране. То су гране које су или
избачене из разматрања јер је закључено да нису део најкраћих путева
(оне су у претходној анимацији обојене црвено) или још нису
размотрене (оне су у претходној анимацији нацртане танко, црном
бојом)</p></li>
</ul>
<p>У старту су сви чворови у скупу <span class="math notranslate nohighlight">\(B_2\)</span> а све гране у скупу
<span class="math notranslate nohighlight">\(III\)</span>. Најближи чвор почетном је сам почетни чвор (до њега је
растојање 0). Зато се почетни чвор пребацује у скуп <span class="math notranslate nohighlight">\(A\)</span> и
понављају се следећа два корака:</p>
<ul class="simple">
<li><p>корак 1: разматрају се све гране <span class="math notranslate nohighlight">\(e\)</span> које повезују чвор
<span class="math notranslate nohighlight">\(u\)</span> који је управо убачен у <span class="math notranslate nohighlight">\(A\)</span> са чворовима <span class="math notranslate nohighlight">\(v\)</span> из
скупа <span class="math notranslate nohighlight">\(B\)</span>. Ако чвор <span class="math notranslate nohighlight">\(v\)</span> припада скупу <span class="math notranslate nohighlight">\(B_1\)</span>
проверава се да ли је пут од почетног чвора до чвора <span class="math notranslate nohighlight">\(v\)</span> краћи
ако се иде преко чвора <span class="math notranslate nohighlight">\(u\)</span> и преко гране <span class="math notranslate nohighlight">\(e\)</span>, него ако се
иде преко чвора <span class="math notranslate nohighlight">\(u\)</span> и преко гране <span class="math notranslate nohighlight">\(e'\)</span> из скупа <span class="math notranslate nohighlight">\(II\)</span>
која је повезивала <span class="math notranslate nohighlight">\(v\)</span> са чворовима из <span class="math notranslate nohighlight">\(A\)</span> (пре додавања
чвора <span class="math notranslate nohighlight">\(u\)</span> у скуп <span class="math notranslate nohighlight">\(A\)</span>). Ако је нови пут краћи грана
<span class="math notranslate nohighlight">\(e\)</span> мења грану <span class="math notranslate nohighlight">\(e'\)</span> у скупу <span class="math notranslate nohighlight">\(II\)</span>, а у супротном
грана <span class="math notranslate nohighlight">\(e\)</span> се одбацује. Ако чвор <span class="math notranslate nohighlight">\(v\)</span> припада скупу <span class="math notranslate nohighlight">\(B_2\)</span>,
тада он раније није био повезан са чворовима из <span class="math notranslate nohighlight">\(A\)</span> и грана <span class="math notranslate nohighlight">\(e\)</span>
се додаје у скуп <span class="math notranslate nohighlight">\(II\)</span>.</p></li>
<li><p>корак 2: Сваки чвор у скупу <span class="math notranslate nohighlight">\(B_1\)</span> се може повезати са почетним
чвором на јединствен начин ако се разматрају само гране из скупова
<span class="math notranslate nohighlight">\(I\)</span> и <span class="math notranslate nohighlight">\(II\)</span>. На тај начин је одређено јединствено
растојање од почетног чвора до сваког чвора у скупу <span class="math notranslate nohighlight">\(B_1\)</span>
(растојање до чворова из <span class="math notranslate nohighlight">\(B_2\)</span> се може сматрати
<span class="math notranslate nohighlight">\(+\infty\)</span>). Чвор из скупа <span class="math notranslate nohighlight">\(B_1\)</span> са најкраћим растојањем
од почетног чвора се пребацује у скуп <span class="math notranslate nohighlight">\(A\)</span> а њему одговарајућа
грана из скупа <span class="math notranslate nohighlight">\(II\)</span> се пребацује у скуп <span class="math notranslate nohighlight">\(I\)</span>. Након тога
се понавља корак 1 и процес се понавља све док се циљни чвор не
пребаци у скуп <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
</ul>
<p>Наредна анимација приказује примену Дајкстриног алгоритма на
одређивање најкраћих путева од Суботице до осталих Војвођанских
градова. Градови до којих је одређено најкраће растојање су обојени у
зелено. Пошто су суседни градови релативно близу један другом, путеви
између њих су скоро прави и у већини случајева дужине путева
задовољавају неједнакост троугла. Стога се почетна процена дужине
најкраћег пута ретко када мења. Ипак, постоји један изузетак. Дужина
пута до Вршца се иницијално процењује на 227,4 km, узевши у обзир пут
преко Кикинде. Касније се та вредност смањује на 213,2 km, узевши у
обзир пут преко Бечеја и Зрењанина. Рецимо и да се у случају када је
познато да за све гране важи неједнакост троугла Дајкстрин алгоритам
може додатно оптимизовати, али се тиме нећемо бавити).</p>
<p>Чворови у скупу <span class="math notranslate nohighlight">\(A\)</span> обојени су зеленом бојом (до њих је познато
најкраће растојање од почетног чвора тј. од Суботице). Бели чворови
припадају скупу <span class="math notranslate nohighlight">\(B\)</span>. Чворови из скупа <span class="math notranslate nohighlight">\(B_1\)</span> су они који
имају коначно растојање и повезани су жутим гранама, а чворови из
скупа <span class="math notranslate nohighlight">\(B_2\)</span> су они који имају бесконачно растојање. Гране из
скупа <span class="math notranslate nohighlight">\(I\)</span> су обојене зеленом бојом, гране из скупа <span class="math notranslate nohighlight">\(II\)</span>
жутом, док су одбачене гране из скупа <span class="math notranslate nohighlight">\(III\)</span> црвене или сиве
(црвене спајају зелене и беле чворове, а сиве гране два зелена чвора).
Неразмотрене гране из скупа <span class="math notranslate nohighlight">\(III\)</span> су означене танким, црним
линијама. У анимацији се наизменично приказује стање након извршавања
корака 1, па затим корака 2 и тако док се не одреде најкраћа растојања
до свих градова (на првој слици је приказано убацивање почетног града
у скуп <span class="math notranslate nohighlight">\(A\)</span>, након тога се извршава корак 1 и три гране се додају
у скуп <span class="math notranslate nohighlight">\(B\)</span>, након тога се извршава корак 2 којим се Бачка Топола
пребацује у скуп <span class="math notranslate nohighlight">\(A\)</span>, а грана која је спаја са Cуботицом у скуп
<span class="math notranslate nohighlight">\(I\)</span>, након тога се понавља корак 1 који анализира гране од Бачке
Тополе до њој суседних градова из скупа <span class="math notranslate nohighlight">\(B\)</span>, након тога корак 2
у ком се Сомбор убацује у скуп <span class="math notranslate nohighlight">\(A\)</span> итд.).</p>

    <div class="gallery" id="dajkstra_vojv">
        <div>
            <div style="width: 650px;height:100%">
            <img src="../_images/dajkstra_vojv0.png" width="100%" height="100%">
<img src="../_images/dajkstra_vojv1.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv2.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv3.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv4.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv5.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv6.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv7.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv8.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv9.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv10.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv11.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv12.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv13.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv14.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv15.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv16.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv17.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv18.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv19.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv20.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv21.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv22.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv23.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv24.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv25.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv26.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv27.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv28.png" width="100%" height="100%" style="display: none;">
<img src="../_images/dajkstra_vojv29.png" width="100%" height="100%" style="display: none;">



            </div>
        </div>
    </div>
    <div class="nav-gallery row" id="dajkstra_vojv-nav">
        <div class="prev-img">
        &#10094;
        </div>
        <div class="next-img">
        <span class="float-right">&#10095;</span>
        </div>
    </div>
<p>Прикажимо сада и имплементацију Дајкстриног алгоритма у језику
C#. Претпостављамо да је у питању редак граф, који представљамо
коришћењем листама суседа. За сваки чвор се памти листа грана у облику
уређених парова који се састоје од дужине гране (реалан број) и редног
броја суседног чвора (природан број). Након учитавања графа учитавају
се и редни број почетног и циљног чвора. Низ <code class="docutils literal notranslate"><span class="pre">duzinaPuta</span></code> садржи
дужину најкраћег до тада пронађеног пута до сваког чвора (то је низ
<span class="math notranslate nohighlight">\(r_v\)</span> из теоријског објашњења). Пошто желимо да поред дужине
пута одредимо и сам најкраћи пут (тј. чворове на том путу), у помоћном
низу <code class="docutils literal notranslate"><span class="pre">roditelji</span></code> за сваки чвор памтимо претходни чвор на најкраћем
путу до њега. Тада најкраћи пут до било ког чвора можемо одредити
праћењем родитеља од циља према старту и обртањем редоследа добијеног
низа чворова. Чворове до којих је одређена дужина најкраћег пута
(решене чворове, тј. чворове из скупа <span class="math notranslate nohighlight">\(V_k\)</span>) региструјемо помоћу
низа логичких вредности <code class="docutils literal notranslate"><span class="pre">resen</span></code>. Главна петља Дајкстриног алгоритма
се извршава све док циљни чвор не постане решен (или док се не реше
сви чворови ако не постоји неки посебно истакнути циљни чвор). У
унутрашњој петљи анализом свих чворова проналазимо онај нерешени чвор
<code class="docutils literal notranslate"><span class="pre">cvorMin</span></code> који је тренутно најближи почетном (ако такав чвор не
постоји, онда циљ није достижан). Тај чвор проглашавамо решеним
(додајемо га у скуп <span class="math notranslate nohighlight">\(V_k\)</span>). Ако је у питању циљни чвор,
алгоритам се прекида јер је одређено растојање од почетног до циљног
чвора. У супротном анализирамо све суседе чвora <code class="docutils literal notranslate"><span class="pre">cvorMin</span></code> и
ажурирамо дужине најкраћих путева до његових суседа, ако је то
потребно. Након завршетка петље, коришћењем помоћног низа
<code class="docutils literal notranslate"><span class="pre">roditelji</span></code> можемо реконструисати пут од циља до старта. Пошто нам
је потребан пут од старта до циља, користимо помоћни стек да бисмо
обрнули редослед чворова.</p>

<div data-childcomponent="dajkstra_kod" class="course-box course-box-problem course-content">

<textarea data-component="activecode" id=dajkstra_kod data-lang="python" 
      data-timelimit=25000 data-coach="true" data-codelens="true"  
    data-audio=''   
             data-passivecode="true"  data-hidehistory=true
    data-includesrc="using System;
using System.Collections.Generic;
using System.Linq;

using Cvor = System.Int32;
using Duzina = System.Double;
using Par = System.Tuple&lt;System.Double, System.Int32&gt;;

class Program
{
    static void Main(string[] args)
    {
        const Duzina INF = double.PositiveInfinity;
        // ucitavamo graf - koristimo liste suseda
        int n = int.Parse(Console.ReadLine());
        List&lt;Par&gt;[] susedi = new List&lt;Par&gt;[n];
        for (int i = 0; i &lt; n; i++)
            susedi[i] = new List&lt;Par&gt;();
        int m = int.Parse(Console.ReadLine());
        for (int i = 0; i &lt; m; i++)
        {
            string[] str = Console.ReadLine().Split();
            Cvor cvorOd = Cvor.Parse(str[0]);
            Cvor cvorDo = Cvor.Parse(str[1]);
            Duzina duzina  = Duzina.Parse(str[2]);
            susedi[cvorOd].Add(Tuple.Create(duzina, cvorDo));
        }
        // ucitavamo startni i ciljni cvor
        int start = int.Parse(Console.ReadLine());
        int cilj = int.Parse(Console.ReadLine());

        // za svaki cvor cuvamo duzinu najkraceg poznatog puta od startnog cvora
        Duzina[] duzinaPuta = Enumerable.Repeat(INF, n).ToArray();
        // zatim da li ta procena predstavlja upravo najkraci moguci put
        bool[] resen = new bool[n];        
        // kao i prethodni cvor na tom trenutno procenjenom najkracem putu
        Cvor[] roditelji = Enumerable.Repeat(-1, n).ToArray();
        // u pocetku jedino znamo rastojanje do startnog cvora
        duzinaPuta[start] = 0.0;
        // dok ne odredimo najkraci put za sve cvorove
        int brojResenih = 0;
        while (brojResenih &lt; n)
        {
            // odredjujemo nereseni cvor koji je trenutno najblizi startnom
            Cvor cvorMin = -1; Duzina minDuzina = INF;
            for (Cvor cvor = 0; cvor &lt; n; cvor++)
                if (!resen[cvor] &amp;&amp; duzinaPuta[cvor] &lt; minDuzina)
                {
                    cvorMin = cvor;
                    minDuzina = duzinaPuta[cvor];
                }
            // ako su svi dostizni cvorovi reseni, ciljni cvor nije dostizan
            if (cvorMin == -1)
                break;
    
            // nije moguce da postoji bolji put do cvoraMin - belezimo da je on
            // resen i povecavamo broj resenih cvorova
            resen[cvorMin] = true;
            brojResenih++;
            // ako je za ciljni cvor odredjeno rastojanje, nema potrebe vrsiti
            // dalju pretragu
            if (cvorMin == cilj)
                break;
            // analiziramo susede cvoraMin
            foreach (Par p in susedi[cvorMin])
            {
                Cvor cvor = p.Item2;
                Duzina duzina = p.Item1;
                // ako je potrebno, azuriramo duzine puta do njegovih suseda
                if (!resen[cvor] &amp;&amp; minDuzina + duzina &lt; duzinaPuta[cvor])
                {
                    duzinaPuta[cvor] = minDuzina + duzina;
                    roditelji[cvor] = cvorMin;
                }
            }
        }

        // ako put do cilja postoji
        if (duzinaPuta[cilj] &lt; INF)
        {
            // ispisujemo duzinu najkraceg puta
            Console.WriteLine(duzinaPuta[cilj].ToString(&quot;0.00000&quot;));
            // pratimo put od cilja do starta, unatrag
            // da bismo obrnuli put, koristimo stek
            var put = new Stack&lt;Cvor&gt;();
            put.Push(cilj);
            while (roditelji[cilj] != -1)
            {
                cilj = roditelji[cilj];
                put.Push(cilj);
            }
            // ispisujemo put od starta do cilja
            while (put.Count &gt; 0)
                Console.Write(put.Pop() + &quot; &quot;);
            Console.WriteLine();
        } else
            // prijavljujemo da put do cilja ne postoji
            Console.WriteLine(&quot;ne&quot;);
    }
}
"   >


</textarea>
</div>
<p>Имплементација која је приказана је елементарна, али није
најефикаснија могућа. Наиме, у сваком кораку се пролазе сви чворови да
би се пронашао онај нерешени чвор који је у том тренутку најближи
почетном чвору. Ако је <span class="math notranslate nohighlight">\(|V|\)</span> број чворова графа, спољна петља се
извршава <span class="math notranslate nohighlight">\(|V|\)</span> пута, док унутрашња петља такође увек прави
<span class="math notranslate nohighlight">\(|V|\)</span> корака, што само по себи генерише квадратну сложеност у
односу на број чворова <span class="math notranslate nohighlight">\(|V|\)</span>. Чак иако би се у унутрашњој петљи
анализирали само нерешени чворови, сложеност би остала квадратна.</p>
<p>Ефикасније имплементације овог алгоритма користе ред са приоритетом, у
ком се чувају нерешени чворови уређени по тренутном растојању од
почетног чвора, који омогућава да се најближи чвор пронађе у времену
<span class="math notranslate nohighlight">\(O(1)\)</span>. Ту се подразумева да чвор који има најмању вредност
растојања има заправо највећи приоритет и да ће први бити избачен из
реда. Убацивање елемената у ред са приоритетом и избацивање елемената
из њега је могуће у времену <span class="math notranslate nohighlight">\(O(\log(k))\)</span>, где је <span class="math notranslate nohighlight">\(k\)</span>
тренутни број елемената у реду, што даје могућност да се направи
имплементација чија је сложеност <span class="math notranslate nohighlight">\(O((|E| + |V|)\log
|V|)\)</span>. Заинтересоване читаоце упућујемо на Методичку збирку задатака
на порталу petlja.org у ком је та имплементација детаљно описана.</p>
</div>
<div class="section" id="id3">
<h2>Сви најкраћи путеви<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>Најкраће путеве између свих парова чворова можемо одредити тако што из
сваког чвора покренемо Дајкстрин алгоритам. Уз ефикасну имплементацију
Дајкстриног алгоритма у ретким графовима (код којих је број грана пре
у линеарној, а не квадратној вези са бројем чворова) сложеност тог
приступа је <span class="math notranslate nohighlight">\(O(|V|^2\log(|V|)\)</span>. Међутим, у густим графовима овај
приступ даје сложеност <span class="math notranslate nohighlight">\(O(|V|^3\log(|V|)\)</span> и тада је чак боље
користити наивну имплементацију Дајкстриног алгоритма, која је
сложености <span class="math notranslate nohighlight">\(O(|V|^2)\)</span> и која даје укупну сложеност
<span class="math notranslate nohighlight">\(O(V^3)\)</span>. У наставку ћемо видети два још једноставнија алгоритма
који решавају овај проблем у сложености <span class="math notranslate nohighlight">\(O(|V|^3)\)</span> без обзира на
број грана у графу. За разлику од Дајкстриног, ове алгоритме је могуће
применити и на граф који садржи гране негативне дужине док год не
садржи циклусе негативне дужине, што је још један значајан аргумент у
њихову корист. Ово је заправо најопштији могући случај, јер чим граф
садржи циклус негативне дужине, дужина најкраћег пута није јасно
дефинисана (можемо се кретати тим циклусом и тиме произвољно смањивати
дужину). Ако нема циклуса негативне дужине, најкраћи путеви не садрже
циклусе (нема чворова који се понављају). Наиме, уклањање циклуса
тј. дела пута од неког поновљеног чвора <span class="math notranslate nohighlight">\(i\)</span> до тог истог чвора
<span class="math notranslate nohighlight">\(i\)</span> не може да повећа дужину пута, па уклањањем циклуса из
путева добијају краћи путеви (или бар путеви исте дужине).</p>
<p>Рецимо и да свих парова чворова има <span class="math notranslate nohighlight">\(|V|^2\)</span>, па се дужине свих
најкраћих путева најбоље репрезентују матрицом димензије <span class="math notranslate nohighlight">\(|V|
\times |V|\)</span>. Ако је граф неусмерен, онда је довољно памтити само горњи
(или само доњи) троугао те матрице.</p>
<div class="section" id="id4">
<h3>Додавање чворова у граф<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Пре него што опишемо Флојд-Варшалов алгоритам, опишимо један алгоритам
који је можда лакше осмислити и разумети, али теже га је програмски
реализовати. Претпоставимо да су тежине свих грана
позитивне. Употребљавамо индуктивно-рекурзивну конструкцију по
чворовима графа (градовима). Индуктивна претпоставка је да умемо да
одредимо све најкраће путеве у графу од <span class="math notranslate nohighlight">\(n\)</span> чворова.</p>
<p>Приликом додавања новог чвора <span class="math notranslate nohighlight">\(i\)</span> у граф, одређујемо најкраће
путеве од сваког чвора <span class="math notranslate nohighlight">\(j\)</span> који је међу <span class="math notranslate nohighlight">\(n\)</span> већ обрађених
чворова до новог чвора <span class="math notranslate nohighlight">\(i\)</span>. Ти путеви су или директни или се
последња деоница у њима остварује тако што се од неког већ обрађеног
чвора <span class="math notranslate nohighlight">\(k\)</span> стигне до чвора <span class="math notranslate nohighlight">\(i\)</span>. Дужина од <span class="math notranslate nohighlight">\(j\)</span> до
<span class="math notranslate nohighlight">\(i\)</span> преко чвора <span class="math notranslate nohighlight">\(k\)</span> једнака је збиру дужине најкраћег пута
од чвора <span class="math notranslate nohighlight">\(j\)</span> до чвора <span class="math notranslate nohighlight">\(k\)</span> и дужини гране од чвора
<span class="math notranslate nohighlight">\(k\)</span> до чвора <span class="math notranslate nohighlight">\(i\)</span>. Притом, пошто нема негативних циклуса,
најкраћи путеви не садрже циклусе тј. поновљене чворове, па пут од
чвора <span class="math notranslate nohighlight">\(j\)</span> до чвора <span class="math notranslate nohighlight">\(k\)</span> не садржи чвор <span class="math notranslate nohighlight">\(i\)</span> (јер би се
онда чвор <span class="math notranslate nohighlight">\(i\)</span> понављао). Најкраћи пут од <span class="math notranslate nohighlight">\(j\)</span> до <span class="math notranslate nohighlight">\(k\)</span>
који не укључује <span class="math notranslate nohighlight">\(i\)</span> већ знамо на основу индуктивне
хипотезе. Дакле, поредимо дужину директне гране од <span class="math notranslate nohighlight">\(j\)</span> до
<span class="math notranslate nohighlight">\(i\)</span> и збирове дужина путева од <span class="math notranslate nohighlight">\(j\)</span> до <span class="math notranslate nohighlight">\(k\)</span> и гране од
<span class="math notranslate nohighlight">\(k\)</span> до <span class="math notranslate nohighlight">\(i\)</span> за свако могуће <span class="math notranslate nohighlight">\(k\)</span> из скупа већ
обрађених чворова и минимум тих растојања представља најкраћи пут од
<span class="math notranslate nohighlight">\(j\)</span> до <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>Дужину најкраћег пута од новог чвора <span class="math notranslate nohighlight">\(i\)</span> до сваког чвора
<span class="math notranslate nohighlight">\(j\)</span> који је међу <span class="math notranslate nohighlight">\(n\)</span> раније обрађених чворова у графу
одређујемо аналогно.</p>
<p>На крају, додавање новог чвора <span class="math notranslate nohighlight">\(i\)</span> у граф можда скраћује дужину
неког пута од раније обрађеног чвора <span class="math notranslate nohighlight">\(j\)</span> до раније обрађеног
чвора <span class="math notranslate nohighlight">\(k\)</span>. Потребно је за све такве парове упоредити дужину
тренутно најкраћег пута (који не укључује чвор <span class="math notranslate nohighlight">\(i\)</span>) и збир
дужина најкраћих путева од <span class="math notranslate nohighlight">\(j\)</span> до <span class="math notranslate nohighlight">\(i\)</span> и од <span class="math notranslate nohighlight">\(i\)</span> до
<span class="math notranslate nohighlight">\(k\)</span> (које смо у првој фази након додавања чвора <span class="math notranslate nohighlight">\(i\)</span>
одредили).</p>
<p>Додавање сваког новог чвора захтева <span class="math notranslate nohighlight">\(O(|V|^2)\)</span> корака, па је
укупна временска сложеност <span class="math notranslate nohighlight">\(O(|V|^3)\)</span>.</p>
<p>У наставку је приказана програмска реализација овог алгоритма у језику
C#. Граф је представљен матрицом тежина.</p>

<div data-childcomponent="svi_najkraci_dodavanje_cvorova_kod" class="course-box course-box-problem course-content">

<textarea data-component="activecode" id=svi_najkraci_dodavanje_cvorova_kod data-lang="python" 
      data-timelimit=25000 data-coach="true" data-codelens="true"  
    data-audio=''   
             data-passivecode="true"  data-hidehistory=true
    data-includesrc="using System;

class Program
{

    // Indukcijom po broju cvorova izracunavamo duzine najkracih
    // puteva izmedju svaka dva cvora u grafu
    static int[,] SviNajkraciPutevi(int[,] D, int n)
    {
        int[,] minD = new int[n, n];

        // dodajemo jedan po jedan cvor
        for (int i = 0; i &lt; n; i++)
        {
            minD[i, i] = 0;

            // odredjujemo najkrace puteve od cvora i do svih prethodnih
            // cvorova j
            for (int j = 0; j &lt; i; j++)
            {
                // pretpostavljamo da je direktno rastojanje najkrace
                minD[i, j] = D[i, j];
                // proveravamo da li je mozda bolji put od i do j koji
                // vodi preko nekog prethodnog cvora k
                for (int k = 0; k &lt; i; k++)
                    if (D[i, k] + minD[k, j] &lt; minD[i, j])
                        minD[i, j] = D[i, k] + minD[k, j];
            }

            // odredjujemo najkrace puteve do cvora i od svih prethodnih
            // cvorova j
            for (int j = 0; j &lt; i; j++)
            {
                // pretpostavljamo da je direktno rastojanje najkrace
                minD[j, i] = D[j, i];
                // proveravamo da li je mozda bolji put od cvora j do i koji
                // vodi preko nekog prethodnog cvora k
                for (int k = 0; k &lt; i; k++)
                    if (minD[j, k] + D[k, i] &lt; minD[j, i])
                        minD[j, i] = minD[j, k] + D[k, i];
            }

            // popravljamo rastojanja od prethodnih cvorova j do prethodnih
            // cvorova k, analizirajuci puteve koji vode preko cvora i
            for (int j = 0; j &lt; i; j++)
                for (int k = 0; k &lt; i; k++)
                    if (minD[j, i] + minD[i, k] &lt; minD[j, k])
                        minD[j, k] = minD[j, i] + minD[i, k];
        }

        return minD;
    }
    

    static void Main(string[] args)
    {
        // ucitavamo duzine direktnih puteva
        int n = int.Parse(Console.ReadLine());
        int[,] D = new int[n, n];
        for (int i = 0; i &lt; n; i++)
        {
            string[] str = Console.ReadLine().Split();
            for (int j = 0; j &lt; n; j++)
                D[i, j] = int.Parse(str[j]);
        }

        // racunamo sve najkrace puteve
        int[,] minD = SviNajkraciPutevi(D, n);

        // ispisujemo rezultat
        for (int i = 0; i &lt; n; i++)
        {
            for (int j = 0; j &lt; n; j++)
                Console.Write((D[i, j] - minD[i, j]) +  &quot; &quot;);
            Console.WriteLine();
        }
    }
}
"   >


</textarea>
</div>
</div>
<div class="section" id="id5">
<h3>Флојд-Варшалов алгоритам<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>Овај елегантан алгоритам су независно открили Роберт Флојд, Стивен
Варшал, Бертран Рој, Питер Ингерман и у мало специфичном облику Стивен
Клини.</p>
<p>Основна идеја Флојд-Варшаловог алгоритма је да се у сваком кораку
<span class="math notranslate nohighlight">\(k\)</span> пронађу најкраћа растојања између свих парова чворова, али
само преко путева који осим почетног и крајњег чвора садрже
међучворове који припадају неком скупу чворова <span class="math notranslate nohighlight">\(V_k\)</span>. Тај скуп
је иницијално празан и у сваком наредном кораку се проширује неким
новим чвором, све док на крају не обухвати све чворове графа (у том
тренутку не постоје никаква ограничења на допуштене путеве и знамо да
су пронађена тражена најкраћа растојања). Редослед додавања чворова у
скуп <span class="math notranslate nohighlight">\(V_k\)</span> није битан и обично се чворови додају у унапред датом
редоследу њихове нумерације.</p>
<p>Базу индукције чини следеће разматрање. Када је скуп <span class="math notranslate nohighlight">\(V_k\)</span>
празан, путеви не смеју да садрже ниједан међу чвор, па је су
допуштени само директни путеви (гране графа). To значи да се матрица
свих најкраћих путева може иницијализовати матрицом тежина грана.</p>
<p>Опишимо сада и шта се дешава током индуктивног корака тј. приликом
додавања неког чвора <span class="math notranslate nohighlight">\(k\)</span> скупу <span class="math notranslate nohighlight">\(V_k = \{0, 1, \ldots,
k-1\}\)</span>. Размотримо шта се дешава са најкраћим путем између нека два
чвора <span class="math notranslate nohighlight">\(i\)</span> и <span class="math notranslate nohighlight">\(j\)</span>.  Постоје две могућности:</p>
<ol class="arabic simple">
<li><p>Најкраћи пут између <span class="math notranslate nohighlight">\(i\)</span> и <span class="math notranslate nohighlight">\(j\)</span> који сме да садржи
чворове скупа <span class="math notranslate nohighlight">\(V_k \cup {k}\)</span> не садржи чвор <span class="math notranslate nohighlight">\(k\)</span> (он
садржи само неке од чворова из скупа <span class="math notranslate nohighlight">\(V_k = \{0, 1, \ldots,
k-1\}\)</span>).</p></li>
<li><p>Најкраћи пут између <span class="math notranslate nohighlight">\(i\)</span> и <span class="math notranslate nohighlight">\(j\)</span> који сме да садржи
чворове скупа <span class="math notranslate nohighlight">\(V_k \cup {k}\)</span> садржи чвор <span class="math notranslate nohighlight">\(k\)</span>. Тада се
чвор <span class="math notranslate nohighlight">\(k\)</span> на том путу налази само једном (јер најкраћи путеви
у графу без негативних циклуса не садрже поновљене чворове). Тај се
пут онда разлаже на најкраћи пут од <span class="math notranslate nohighlight">\(i\)</span> до <span class="math notranslate nohighlight">\(k\)</span> и
најкраћи пут од <span class="math notranslate nohighlight">\(k\)</span> до <span class="math notranslate nohighlight">\(j\)</span>, при чему оба та најкраћа
пута као међучворове садрже само чворове из скупа <span class="math notranslate nohighlight">\(V_k\)</span> и
зато их на основу индуктивне хипотезе већ знамо.</p></li>
</ol>
<a class="reference internal image-reference" href="../_images/flojdVarsalShema.png"><img alt="../_images/flojdVarsalShema.png" class="align-center" src="../_images/flojdVarsalShema.png" style="width: 700px;" /></a>
<p>Ако са <span class="math notranslate nohighlight">\(w_{ij}\)</span> означимо тежину гране између чворова <span class="math notranslate nohighlight">\(i\)</span> и
<span class="math notranslate nohighlight">\(j\)</span>, а са <span class="math notranslate nohighlight">\(d^k(i, j)\)</span> означимо дужину најкраћег пута
између чворова <span class="math notranslate nohighlight">\(i\)</span> и <span class="math notranslate nohighlight">\(j\)</span> који користе само међучворове из
скупа <span class="math notranslate nohighlight">\(V_k = \{0, 1, \ldots, k-1\}\)</span>, тада важе следеће
рекурентне везе:</p>
<div class="math notranslate nohighlight">
\[d^0(i, j) = w_{ij}\]</div>
<div class="math notranslate nohighlight">
\[d^{k+1}(i, j) = \min(d^k(i, j), d^k(i, k) + d^k(k, j))\]</div>
<p>Прикажимо сада рад овог алгоритма на једном примеру.</p>

    <div class="gallery" id="flojdVarsal_primer">
        <div>
            <div style="width: 900px;height:100%">
            <img src="../_images/FV1.png" width="100%" height="100%">
<img src="../_images/FV2.png" width="100%" height="100%" style="display: none;">
<img src="../_images/FV3.png" width="100%" height="100%" style="display: none;">
<img src="../_images/FV4.png" width="100%" height="100%" style="display: none;">
<img src="../_images/FV5.png" width="100%" height="100%" style="display: none;">
<img src="../_images/FV6.png" width="100%" height="100%" style="display: none;">
<img src="../_images/FV7.png" width="100%" height="100%" style="display: none;">



            </div>
        </div>
    </div>
    <div class="nav-gallery row" id="flojdVarsal_primer-nav">
        <div class="prev-img">
        &#10094;
        </div>
        <div class="next-img">
        <span class="float-right">&#10095;</span>
        </div>
    </div>
<p>Ова анимација је креирана коришћењем веб-апликације доступне на сајту
Математичког факултета у Београду
(<a class="reference external" href="http://www.matf.bg.ac.rs/~filip/algoritmi/flojdVarsal.html">http://www.matf.bg.ac.rs/~filip/algoritmi/flojdVarsal.html</a>). Покушај
да коришћењем ове апликације учврштиш своје разумевање рада овог
алгоритма.</p>
<p>Имплементација алгоритма је веома једноставна и у њој се матрица
најкраћих растојања ажурира у три угнежђене петље. Јако је важно
нагласити да се у спољној петљи врши итерација кроз допуштене
међучворове, а да се у унутрашњим петљама врши итерација кроз поља
матрице (међучвор мора да буде у спољашњој петљи и ако је он означен
са <code class="docutils literal notranslate"><span class="pre">k</span></code>, а ако су чворови између којих се ажурира пут обележени са
<code class="docutils literal notranslate"><span class="pre">i</span></code> и <code class="docutils literal notranslate"><span class="pre">j</span></code>, тада редослед петљи треба да буде <code class="docutils literal notranslate"><span class="pre">k-i-j</span></code>, а не
<code class="docutils literal notranslate"><span class="pre">i-j-k</span></code>).</p>

<div data-childcomponent="flojdVarsal_kod" class="course-box course-box-problem course-content">

<textarea data-component="activecode" id=flojdVarsal_kod data-lang="python" 
      data-timelimit=25000 data-coach="true" data-codelens="true"  
    data-audio=''   
             data-passivecode="true"  data-hidehistory=true
    data-includesrc="using System;

class Program
{

    // Flojd-Varsalovim algoritmom izracunavamo duzine najkracih
    // puteva izmedju svaka dva cvora u grafu
    static int[,] SviNajkraciPutevi(int[,] D, int n)
    {
        int[,] minD = (int[,])D.Clone();
        for (int k = 0; k &lt; n; k++) {
            for (int i = 0; i &lt; n; i++)
                for (int j = 0; j &lt; n; j++)
                    if (minD[i, k] + minD[k, j] &lt; minD[i, j])
                        minD[i, j] = minD[i, k] + minD[k, j];
        }
        return minD;
    }
    

    static void Main(string[] args)
    {
        // ucitavamo duzine direktnih puteva 
        int n = int.Parse(Console.ReadLine());
        int[,] D = new int[n, n];
        for (int i = 0; i &lt; n; i++)
        {
            string[] str = Console.ReadLine().Split();
            for (int j = 0; j &lt; n; j++)
                D[i, j] = int.Parse(str[j]);
        }

        // racunamo duzine svih najkracih puteva
        int[,] minD = SviNajkraciPutevi(D, n);

        // ispisujemo rezultat
        for (int i = 0; i &lt; n; i++)
        {
            for (int j = 0; j &lt; n; j++)
                Console.Write((D[i, j] - minD[i, j]) +  &quot; &quot;);
            Console.WriteLine();
        }
    }
}
"   >


</textarea>
</div>
<p>Из ове имплементације је сасвим јасно да је сложеност овог алгоритма
<span class="math notranslate nohighlight">\(O(|V|^3)\)</span>.</p>
<p>Пробајте за вежбу да модификујете претходни програм тако да осим дужина
путева, за сваки пар чворова испише и саме најкраће путеве.</p>
</div>
<div class="section" id="id6">
<h3>Транзитивно затворење<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>Флојд-Варшалов алгоритам се може употребити и за проналажење
транзитивног затворења релације. Подсетимо се, бинарна релација
<span class="math notranslate nohighlight">\(\rho\)</span> на скупу <span class="math notranslate nohighlight">\(A\)</span> је било који подскуп <span class="math notranslate nohighlight">\(A \times
A\)</span>. Транзитивно затворење дате релације <span class="math notranslate nohighlight">\(\rho\)</span> је најмања
релација <span class="math notranslate nohighlight">\(\rho^+\)</span> која садржи дату релацију (важи <span class="math notranslate nohighlight">\(\rho
\subseteq \rho^+\)</span>), а која је транзитивна. Другим речима, потребно је
постојећој релацији додати што мањи број нових уређених парова, тако
да се добије транзитивна релација.</p>
<p>На наредој слици је графом представљена једна једноставна релација и
њено транзитивно затворење.  Гране које је потребно додати да би
релација постала транзитивна су обојене црвеном бојом. Пошто је A у
релацији са B, а B је у релацији са C, да би релација била транзитивна
потребно је и да A буде у релацији са C. Слично, пошто је B у релацији
са C, а C у релацији са D, мора да важи и да је B у релацији са D. На
крају, пошто је након додавања гране A у релацији са C и пошто је C у
релацији са D, мора да важи и да је A у релацији са D (исти закључак
следи и због тога што је A у релацији са B и B у релацији са D). Након
додавања три гране, релација је постала транзитивна.</p>
<a class="reference internal image-reference" href="../_images/tranzitivno_zatvorenje.png"><img alt="../_images/tranzitivno_zatvorenje.png" class="align-center" src="../_images/tranzitivno_zatvorenje.png" style="width: 400px;" /></a>
<p>У транзитивним релацијама сви достижни чворови су достижни директно,
преко једне гране. Стога је за одређивање транзитивног затворења за
сваки чвор потребно одредити који су чворови из њега достижни. Ово се
може свести на проблем свих најкраћих путева тако што се гранама
вештачки доделе дужине 1 и у тако формираном графу одреде дужине свих
најкраћих путева Флојд-Варшаловим алгоритмом. Достижне чворове ћемо
препознати као оне чворове код којих је најкраће растојање коначно
(код недостижних чворова остаће иницијална вредност
бесконачно). Можемо отићи и један корак даље - пошто нас занима само
да ли постоји пут, а не и која је његова дужина, можемо формирати
логичку матрицу коју ћемо иницијализовати тако што ћемо на места која
одговарају чворовима који су повезани граном стављати вредност тачно,
а на остала места нетачно. Пут између чворова <span class="math notranslate nohighlight">\(i\)</span> и <span class="math notranslate nohighlight">\(j\)</span>
преко међучворова из скупа <span class="math notranslate nohighlight">\(\{0, \ldots, k\}\)</span> постоји ако и само
ако постоји пут преко међучворова из скупа <span class="math notranslate nohighlight">\(\{0, \ldots, k-1\}\)</span>
или постоји пут од <span class="math notranslate nohighlight">\(i\)</span> до <span class="math notranslate nohighlight">\(k\)</span> и од <span class="math notranslate nohighlight">\(k\)</span> до <span class="math notranslate nohighlight">\(j\)</span>
преко чворова из скупа <span class="math notranslate nohighlight">\(\{0, \ldots, k-1\}\)</span>.  Тако модификована
варијанта Флојд-Варшаловог алгоритма је заснована на следећим
рекурентним релацијама (<span class="math notranslate nohighlight">\(A_{ij}\)</span> је елемент матрице повезаности,
док <span class="math notranslate nohighlight">\(t^k(i, j)\)</span> значи да постоји пут од <span class="math notranslate nohighlight">\(i\)</span> до <span class="math notranslate nohighlight">\(j\)</span>
преко чворова скупа <span class="math notranslate nohighlight">\(\{0, \ldots, k-1\}\)</span>).</p>
<div class="math notranslate nohighlight">
\[t^0(i, j) = A_{ij}\]</div>
<div class="math notranslate nohighlight">
\[t^{k+1}(i, j) = t^k(i, j) \vee (t^k(i, k) \wedge t^k(k, j))\]</div>
<p>Ове везе се веома се једноставно преводе у програм (опет са три
угнежђене петље).</p>
</div>
</div>
</div>


    </div>
    
    <div>
<div class="lecture-prev-next-toggle">
  <a  href="34_tekstualni_dalje.html" id="prevLectureLink" class="lecture-toggler-arrows"><i class="fas fa-arrow-left fa"></i> <span> Претходна лекција </span> </a>
  
  <a id="nextLectureLink" class="lecture-toggler-arrows"><span> Следећа лекција</span>  <i class="fas fa-arrow-right fa"></i> </a>
</div>

<script type="text/javascript">
  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});
</script>
</div>

    
  </div>
</div>

<div class="petljadoc-resources">
  <span class="pull-left">(Created using  <a href="https://pypi.org/project/Sphinx/">Swinx</a>, <a href="http://runestoneinteractive.org/">RunestoneComponents</a> and <a href="https://github.com/Petlja/PetljaDoc">PetljaDoc</a>) <br> © 2022 Petlja</span>
</div>


<div class="lectureToolbox">

  <label class="font-size-toggle" id="fontSizeToggle">

      <i class="fas fa-font"></i><label>Слова</label>
  </label>
  <div class="font-change d-none" id="fontChangeModal">
      <span class="dec-letter-icon" id="decLetterIcon">A-</span>
      <label id="currentFontSize">16</label>
      <span class="inc-letter-icon" id="incLetterIcon">A+</span>
  </div>
</div>

</div>

  </body>
</html>